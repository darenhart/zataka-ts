{"version":3,"file":"main-BcO3pj-R.js","sources":["../../src/core/ImageLoader.ts","../../src/core/KeyboardManager.ts","../../src/types/game.types.ts","../../src/ui/components/Background.ts","../../src/ui/screens/SplashScreen.ts","../../src/ui/screens/EndScreen.ts","../../src/ui/components/ScoreBoard.ts","../../src/core/FpsCounter.ts","../../src/ui/screens/PlayerSelector.ts","../../src/config/gameConfigurations.ts","../../src/ui/components/AdvancedSettings.ts","../../src/game/entities/Player.ts","../../src/game/managers/PlayerManager.ts","../../src/core/Game.ts","../../src/main.ts"],"sourcesContent":["/**\n * Image Loader\n *\n * Handles asynchronous loading of game images/sprites.\n *\n * Migrated from imageRepository in Game.js with improvements:\n * - Class-based with proper encapsulation\n * - Type-safe image repository\n * - Progress tracking\n * - Error handling\n * - No global dependencies\n */\n\nimport type {\n  ImageRepository,\n  ImageLoaderConfig,\n  IImageLoader,\n} from '../types/game.types';\n\n/**\n * ImageLoader class\n *\n * Loads game images and provides access to the repository.\n */\nexport class ImageLoader implements IImageLoader {\n  // Public readonly properties\n  public get images(): Partial<ImageRepository> {\n    return this.#images;\n  }\n\n  public get loaded(): boolean {\n    return this.#loadedCount === this.#totalCount;\n  }\n\n  public get loadedCount(): number {\n    return this.#loadedCount;\n  }\n\n  public get totalCount(): number {\n    return this.#totalCount;\n  }\n\n  // Private state\n  #images: Partial<ImageRepository> = {};\n  #loadedCount: number = 0;\n  #totalCount: number = 0;\n  #onComplete: () => void;\n\n  /**\n   * Create a new image loader\n   *\n   * Immediately begins loading images.\n   *\n   * @param config - Configuration with image paths and completion callback\n   */\n  constructor(config: ImageLoaderConfig) {\n    this.#onComplete = config.onComplete;\n\n    // Count total images\n    this.#totalCount = Object.keys(config.images).length;\n\n    // Start loading images\n    for (const [key, src] of Object.entries(config.images)) {\n      this.#loadImage(key, src);\n    }\n  }\n\n  /**\n   * Load a single image\n   *\n   * @param key - Image key in repository\n   * @param src - Image source path\n   */\n  #loadImage(key: string, src: string): void {\n    const image = new Image();\n    image.src = src;\n\n    image.onload = () => {\n      this.#handleImageLoaded();\n    };\n\n    image.onerror = () => {\n      console.error(`Failed to load image: ${src}`);\n      this.#handleImageLoaded(); // Count as loaded to prevent blocking\n    };\n\n    // Store image in repository\n    (this.#images as Record<string, HTMLImageElement>)[key] = image;\n  }\n\n  /**\n   * Handle image load completion\n   *\n   * Increments loaded count and triggers callback if all images loaded.\n   */\n  #handleImageLoaded(): void {\n    this.#loadedCount++;\n\n    if (this.#loadedCount === this.#totalCount) {\n      this.#onComplete();\n    }\n  }\n}\n\n/**\n * Create a new image loader\n *\n * Factory function for convenient instantiation.\n *\n * @param config - Configuration with image paths and completion callback\n * @returns New ImageLoader instance\n */\nexport function createImageLoader(config: ImageLoaderConfig): IImageLoader {\n  return new ImageLoader(config);\n}\n","/**\n * Keyboard and Mouse Input Manager\n *\n * Manages keyboard and mouse input state for the game using a polling pattern.\n * Provides a singleton instance that tracks which keys/buttons are currently pressed.\n *\n * This replaces the legacy Keys.js global state with a modern class-based approach\n * while maintaining backward compatibility.\n */\n\nimport type {\n  KeyName,\n  KeyStatus,\n  KeyCodesMap,\n  IInputManager,\n} from '../types/input.types.js';\n\n/**\n * Input Manager Singleton\n *\n * Tracks keyboard and mouse button states for game input.\n * Uses polling pattern - consumers check state during game loop\n * rather than responding to events directly.\n *\n * @example\n * ```typescript\n * const input = KeyboardManager.getInstance();\n * input.initialize(document.getElementById('game'));\n *\n * // In game loop\n * if (input.isKeyPressed('space')) {\n *   startGame();\n * }\n * ```\n */\nexport class KeyboardManager implements IInputManager {\n  private static instance: KeyboardManager;\n\n  /** Current state of all tracked keys */\n  private keyStatus: KeyStatus;\n\n  /** Mapping of numeric key codes to key names */\n  private readonly keyCodes: KeyCodesMap;\n\n  /** Reference to game element for mouse events */\n  private gameElement: HTMLElement | null = null;\n\n  /** Event handler references for cleanup */\n  private readonly keydownHandler: (e: KeyboardEvent) => void;\n  private readonly keyupHandler: (e: KeyboardEvent) => void;\n  private readonly mousedownHandler: (e: MouseEvent) => void;\n  private readonly mouseupHandler: (e: MouseEvent) => void;\n\n  /** Whether the manager has been initialized */\n  private initialized = false;\n\n  /**\n   * Private constructor for singleton pattern\n   */\n  private constructor() {\n    // Define key code mappings\n    this.keyCodes = {\n      1: 'mouse1',\n      2: 'mouse2',\n      32: 'space',\n      37: 'left',\n      38: 'up',\n      39: 'right',\n      40: 'down',\n      17: 'Ctrl',\n      16: 'Shift',\n      49: '1',\n      81: 'q',\n      77: 'm',\n      78: 'n',\n      79: 'o',\n      80: 'p',\n    };\n\n    // Initialize key status\n    this.keyStatus = this.createInitialKeyStatus();\n\n    // Create event handlers (stored as properties for cleanup)\n    this.keydownHandler = this.handleKeyDown.bind(this);\n    this.keyupHandler = this.handleKeyUp.bind(this);\n    this.mousedownHandler = this.handleMouseDown.bind(this);\n    this.mouseupHandler = this.handleMouseUp.bind(this);\n  }\n\n  /**\n   * Get the singleton instance\n   */\n  public static getInstance(): KeyboardManager {\n    if (!KeyboardManager.instance) {\n      KeyboardManager.instance = new KeyboardManager();\n    }\n    return KeyboardManager.instance;\n  }\n\n  /**\n   * Initialize key status with all keys set to false\n   */\n  private createInitialKeyStatus(): KeyStatus {\n    const status = {} as KeyStatus;\n    Object.values(this.keyCodes).forEach((keyName) => {\n      status[keyName] = false;\n    });\n    return status;\n  }\n\n  /**\n   * Initialize the input manager\n   *\n   * Attaches event listeners to track keyboard and mouse input.\n   * Must be called after DOM is ready and game element exists.\n   *\n   * @param gameElement - The game container element for mouse events\n   */\n  public initialize(gameElement: HTMLElement): void {\n    if (this.initialized) {\n      console.warn('KeyboardManager already initialized');\n      return;\n    }\n\n    this.gameElement = gameElement;\n    this.attachEventListeners();\n\n    // Prevent context menu on right-click\n    this.gameElement.addEventListener('contextmenu', (e) => e.preventDefault());\n\n    this.initialized = true;\n  }\n\n  /**\n   * Reset singleton instance for testing purposes\n   *\n   * WARNING: Only use this in test environments!\n   * @internal\n   */\n  public static resetInstance(): void {\n    if (KeyboardManager.instance) {\n      KeyboardManager.instance.destroy();\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (KeyboardManager as any).instance = undefined;\n  }\n\n  /**\n   * Attach all event listeners\n   */\n  private attachEventListeners(): void {\n    // Keyboard events on document\n    document.addEventListener('keydown', this.keydownHandler);\n    document.addEventListener('keyup', this.keyupHandler);\n\n    // Mouse events on game element\n    if (this.gameElement) {\n      this.gameElement.addEventListener('mousedown', this.mousedownHandler);\n      this.gameElement.addEventListener('mouseup', this.mouseupHandler);\n    } else {\n      console.error('Game element not found for mouse event listeners');\n    }\n  }\n\n  /**\n   * Handle keydown events\n   */\n  private handleKeyDown(e: KeyboardEvent): void {\n    const keyName = this.keyCodes[e.keyCode];\n    if (keyName) {\n      e.preventDefault();\n      this.keyStatus[keyName] = true;\n    }\n  }\n\n  /**\n   * Handle keyup events\n   */\n  private handleKeyUp(e: KeyboardEvent): void {\n    const keyName = this.keyCodes[e.keyCode];\n    if (keyName) {\n      e.preventDefault();\n      this.keyStatus[keyName] = false;\n    }\n  }\n\n  /**\n   * Handle mousedown events\n   */\n  private handleMouseDown(e: MouseEvent): void {\n    if (e.button === 2) {\n      // Right button\n      this.keyStatus.mouse2 = true;\n      e.preventDefault();\n    } else if (e.button === 0) {\n      // Left button\n      this.keyStatus.mouse1 = true;\n    }\n  }\n\n  /**\n   * Handle mouseup events\n   */\n  private handleMouseUp(e: MouseEvent): void {\n    if (e.button === 2) {\n      // Right button\n      this.keyStatus.mouse2 = false;\n      e.preventDefault();\n    } else if (e.button === 0) {\n      // Left button\n      this.keyStatus.mouse1 = false;\n    }\n  }\n\n  /**\n   * Check if a key is currently pressed\n   *\n   * @param keyName - Name of the key to check\n   * @returns true if the key is currently pressed\n   */\n  public isKeyPressed(keyName: KeyName): boolean {\n    return this.keyStatus[keyName] ?? false;\n  }\n\n  /**\n   * Reset all key states to unpressed\n   *\n   * Useful when switching game states or resetting the game.\n   */\n  public reset(): void {\n    Object.keys(this.keyStatus).forEach((key) => {\n      this.keyStatus[key as KeyName] = false;\n    });\n  }\n\n  /**\n   * Clean up event listeners and state\n   *\n   * CRITICAL: Must be called to prevent memory leaks.\n   * Call this on page unload or when destroying the game instance.\n   */\n  public destroy(): void {\n    // Remove keyboard event listeners\n    document.removeEventListener('keydown', this.keydownHandler);\n    document.removeEventListener('keyup', this.keyupHandler);\n\n    // Remove mouse event listeners\n    if (this.gameElement) {\n      this.gameElement.removeEventListener('mousedown', this.mousedownHandler);\n      this.gameElement.removeEventListener('mouseup', this.mouseupHandler);\n    }\n\n    // Reset state\n    this.reset();\n    this.gameElement = null;\n    this.initialized = false;\n  }\n\n  /**\n   * Get readonly copy of key status\n   *\n   * For backward compatibility with legacy code that accesses KEY_STATUS directly.\n   * Prefer using isKeyPressed() for new code.\n   *\n   * @returns Readonly view of current key status\n   */\n  public getKeyStatus(): Readonly<KeyStatus> {\n    return this.keyStatus;\n  }\n\n  /**\n   * Get all currently pressed keys\n   *\n   * @returns Array of key names that are currently pressed\n   */\n  public getPressedKeys(): KeyName[] {\n    return Object.entries(this.keyStatus)\n      .filter(([, pressed]) => pressed)\n      .map(([key]) => key as KeyName);\n  }\n}\n\n/**\n * Singleton instance for convenient access\n *\n * @example\n * ```typescript\n * import { keyboardManager } from './KeyboardManager';\n *\n * // Initialize once\n * const gameEl = document.getElementById('game');\n * if (gameEl) {\n *   keyboardManager.initialize(gameEl);\n * }\n *\n * // Use anywhere\n * if (keyboardManager.isKeyPressed('space')) {\n *   // ...\n * }\n * ```\n */\nexport const keyboardManager = KeyboardManager.getInstance();\n\n/**\n * Legacy export for backward compatibility\n *\n * Provides KEY_STATUS-like object with live state access.\n * Uses Proxy to delegate property access to the underlying KeyboardManager state.\n *\n * @deprecated Use keyboardManager.isKeyPressed() instead\n * @example\n * ```typescript\n * // Legacy code continues to work\n * if (KEY_STATUS.space) {\n *   startGame();\n * }\n * ```\n */\nexport const KEY_STATUS = new Proxy({} as KeyStatus, {\n  get(_, prop: string | symbol): boolean {\n    if (typeof prop === 'string') {\n      return keyboardManager.isKeyPressed(prop as KeyName);\n    }\n    return false;\n  },\n  set(): boolean {\n    console.warn('KEY_STATUS is readonly. Use keyboardManager methods instead.');\n    return false;\n  },\n});\n\n// Clean up on page unload\nif (typeof window !== 'undefined') {\n  window.addEventListener('beforeunload', () => {\n    keyboardManager.destroy();\n  });\n}\n\n// Hot Module Replacement support (Vite)\nif (import.meta.hot) {\n  import.meta.hot.dispose(() => {\n    keyboardManager.destroy();\n  });\n}\n","/**\n * Game Controller Type Definitions\n *\n * Type definitions for the main game controller, screens, and state management.\n */\n\nimport type { PlayerName } from './player.types';\n\n/**\n * Game state enumeration\n */\nexport enum GameState {\n  /** Showing splash screen */\n  Splash = 'splash',\n\n  /** Player selection screen */\n  Select = 'select',\n\n  /** Game in progress */\n  Playing = 'playing',\n\n  /** Game ended, showing final scores */\n  End = 'end',\n}\n\n/**\n * Canvas layer definition\n */\nexport interface CanvasLayer {\n  /** Canvas element */\n  element: HTMLCanvasElement;\n\n  /** 2D rendering context */\n  context: CanvasRenderingContext2D;\n}\n\n/**\n * All canvas layers used by the game\n */\nexport interface CanvasLayers {\n  /** Main game canvas (player trails) */\n  main: CanvasLayer;\n\n  /** Text overlay canvas (FPS counter) */\n  texts: CanvasLayer;\n\n  /** Screens canvas (splash, select, end) */\n  screens: CanvasLayer;\n\n  /** Scoreboard canvas */\n  score: CanvasLayer;\n}\n\n/**\n * Image repository with all game sprites\n */\nexport interface ImageRepository {\n  /** Splash screen image */\n  splash: HTMLImageElement;\n\n  /** End game image */\n  end: HTMLImageElement;\n\n  /** Red player sprite */\n  red: HTMLImageElement;\n\n  /** Yellow player sprite */\n  yellow: HTMLImageElement;\n\n  /** Orange player sprite */\n  orange: HTMLImageElement;\n\n  /** Green player sprite */\n  green: HTMLImageElement;\n\n  /** Pink player sprite */\n  pink: HTMLImageElement;\n\n  /** Blue player sprite */\n  blue: HTMLImageElement;\n}\n\n/**\n * Configuration for image loading\n */\nexport interface ImageLoaderConfig {\n  /** Image source paths keyed by name */\n  images: Record<string, string>;\n\n  /** Callback when all images are loaded */\n  onComplete: () => void;\n}\n\n/**\n * Interface for image loader implementations\n */\nexport interface IImageLoader {\n  /** Image repository (available after loading) */\n  readonly images: Partial<ImageRepository>;\n\n  /** Whether all images have loaded */\n  readonly loaded: boolean;\n\n  /** Number of images loaded so far */\n  readonly loadedCount: number;\n\n  /** Total number of images to load */\n  readonly totalCount: number;\n}\n\n/**\n * Configuration for Background component\n */\nexport interface BackgroundConfig {\n  /** Border width in pixels (default: 10) */\n  borderWidth?: number;\n\n  /** Border color (default: '#CCCC55') */\n  borderColor?: string;\n}\n\n/**\n * Interface for background implementations\n */\nexport interface IBackground {\n  /**\n   * Draw the game boundary\n   *\n   * @param gameWidth - Total game width\n   * @param gameHeight - Total game height\n   * @param scoreWidth - Width of scoreboard (excluded from play area)\n   */\n  draw(gameWidth: number, gameHeight: number, scoreWidth: number): void;\n\n  /**\n   * Clear the background canvas\n   *\n   * @param gameWidth - Total game width\n   * @param gameHeight - Total game height\n   */\n  clear(gameWidth: number, gameHeight: number): void;\n}\n\n/**\n * Configuration for SplashScreen component\n */\nexport interface SplashScreenConfig {\n  /** Auto-dismiss timeout in frames (default: 100) */\n  timeout?: number;\n}\n\n/**\n * Interface for splash screen implementations\n */\nexport interface ISplashScreen {\n  /** Whether splash screen is currently active */\n  readonly active: boolean;\n\n  /**\n   * Show the splash screen\n   *\n   * @param image - Splash screen image\n   * @param gameWidth - Current game width\n   * @param gameHeight - Current game height\n   */\n  show(image: HTMLImageElement, gameWidth: number, gameHeight: number): void;\n\n  /**\n   * Listen for user input to dismiss\n   *\n   * Called each frame while splash is active.\n   *\n   * @param onDismiss - Callback when user dismisses or timeout expires\n   */\n  listen(onDismiss: () => void): void;\n\n  /**\n   * Clear and hide the splash screen\n   *\n   * @param gameWidth - Current game width\n   * @param gameHeight - Current game height\n   */\n  clear(gameWidth: number, gameHeight: number): void;\n}\n\n/**\n * Player score data for end screen\n */\nexport interface PlayerScore {\n  /** Player name */\n  name: PlayerName;\n\n  /** Player color */\n  color: string;\n\n  /** Final score */\n  score: number;\n}\n\n/**\n * Configuration for EndScreen component\n */\nexport interface EndScreenConfig {\n  /** Wait time before allowing input (frames, default: 100) */\n  waitTime?: number;\n\n  /** Font size for scores (default: 30) */\n  fontSize?: number;\n\n  /** Font family (default: 'Sans-Serif') */\n  fontFamily?: string;\n\n  /** Font weight (default: 'bold') */\n  fontWeight?: string;\n}\n\n/**\n * Interface for end screen implementations\n */\nexport interface IEndScreen {\n  /** Whether end screen is currently active */\n  readonly active: boolean;\n\n  /**\n   * Show the end game screen with final scores\n   *\n   * @param image - End game image\n   * @param scores - Player scores to display\n   * @param gameWidth - Current game width\n   * @param gameHeight - Current game height\n   */\n  show(\n    image: HTMLImageElement,\n    scores: PlayerScore[],\n    gameWidth: number,\n    gameHeight: number\n  ): void;\n\n  /**\n   * Listen for user input to return to select screen\n   *\n   * Called each frame while end screen is active.\n   *\n   * @param onDismiss - Callback when user presses space\n   */\n  listen(onDismiss: () => void): void;\n\n  /**\n   * Clear and hide the end screen\n   *\n   * @param gameWidth - Current game width\n   * @param gameHeight - Current game height\n   */\n  clear(gameWidth: number, gameHeight: number): void;\n}\n\n/**\n * Dependencies required by Game controller\n */\nexport interface GameDependencies {\n  /** Container element for canvases */\n  container: HTMLElement;\n\n  /** Optional GitHub link element to show/hide */\n  githubElement?: HTMLElement;\n\n  /** Callback when window should show cursor */\n  onShowCursor?: () => void;\n\n  /** Callback when window should hide cursor */\n  onHideCursor?: () => void;\n}\n\n/**\n * Interface for game controller implementations\n */\nexport interface IGame {\n  /** Current game state */\n  readonly state: GameState;\n\n  /** Whether game is started (playing) */\n  readonly started: boolean;\n\n  /** Current game width in pixels */\n  readonly width: number;\n\n  /** Current game height in pixels */\n  readonly height: number;\n\n  /**\n   * Initialize the game\n   *\n   * Sets up canvases, components, and shows splash screen.\n   */\n  init(): void;\n\n  /**\n   * Handle window resize\n   *\n   * Recalculates canvas sizes and redraws current screen.\n   */\n  onSizeChange(): void;\n\n  /**\n   * Show splash screen\n   *\n   * Transitions to splash state.\n   */\n  showSplashScreen(): void;\n\n  /**\n   * Show player selection screen\n   *\n   * Transitions to select state.\n   */\n  showSelectScreen(): void;\n\n  /**\n   * Start the game\n   *\n   * Begins a new game with selected players.\n   * Transitions to playing state.\n   */\n  start(): void;\n\n  /**\n   * Start a new round\n   *\n   * Called at the beginning of each round.\n   */\n  newRound(): void;\n\n  /**\n   * End the game\n   *\n   * Shows end screen with final scores.\n   * Transitions to end state.\n   */\n  finish(): void;\n\n  /**\n   * Main animation loop tick\n   *\n   * Should be called once per frame.\n   * Delegates to appropriate screen/state handler.\n   */\n  animate(): void;\n}\n","/**\n * Background Component\n *\n * Renders the game boundary/play area border.\n *\n * Migrated from Background function in Game.js with improvements:\n * - Class-based with proper encapsulation\n * - Configurable border styling\n * - No global game object dependency\n * - Type-safe configuration\n */\n\nimport type { BackgroundConfig, IBackground } from '../../types/game.types';\n\n/**\n * Default configuration values\n */\nconst DEFAULT_CONFIG: Required<BackgroundConfig> = {\n  borderWidth: 10,\n  borderColor: '#CCCC55',\n};\n\n/**\n * Background class\n *\n * Draws a rectangular border around the game play area.\n */\nexport class Background implements IBackground {\n  // Private fields\n  #context: CanvasRenderingContext2D;\n  #config: Required<BackgroundConfig>;\n\n  /**\n   * Create a new background renderer\n   *\n   * @param context - Canvas 2D rendering context\n   * @param config - Optional configuration (uses defaults if not provided)\n   */\n  constructor(context: CanvasRenderingContext2D, config?: BackgroundConfig) {\n    this.#context = context;\n    this.#config = { ...DEFAULT_CONFIG, ...config };\n  }\n\n  /**\n   * Draw the game boundary\n   *\n   * Renders a rectangular border around the play area.\n   *\n   * @param gameWidth - Total game width\n   * @param gameHeight - Total game height\n   * @param scoreWidth - Width of scoreboard (excluded from play area)\n   */\n  public draw(gameWidth: number, gameHeight: number, scoreWidth: number): void {\n    this.#context.save();\n\n    this.#context.beginPath();\n    this.#context.rect(0, 0, gameWidth - scoreWidth, gameHeight);\n    this.#context.lineWidth = this.#config.borderWidth;\n    this.#context.strokeStyle = this.#config.borderColor;\n    this.#context.stroke();\n\n    this.#context.restore();\n  }\n\n  /**\n   * Clear the background canvas\n   *\n   * @param gameWidth - Total game width\n   * @param gameHeight - Total game height\n   */\n  public clear(gameWidth: number, gameHeight: number): void {\n    this.#context.clearRect(0, 0, gameWidth, gameHeight);\n  }\n}\n\n/**\n * Create a new background renderer\n *\n * Factory function for convenient instantiation.\n *\n * @param context - Canvas 2D rendering context\n * @param config - Optional configuration\n * @returns New Background instance\n */\nexport function createBackground(\n  context: CanvasRenderingContext2D,\n  config?: BackgroundConfig\n): IBackground {\n  return new Background(context, config);\n}\n","/**\n * Splash Screen\n *\n * Displays the game splash/intro screen with auto-dismiss timeout.\n *\n * Migrated from SplashScreen function in Game.js with improvements:\n * - Class-based with proper encapsulation\n * - Dependency injection for input manager\n * - Configurable timeout\n * - Callback pattern for dismiss action\n * - Type-safe configuration\n */\n\nimport type {\n  SplashScreenConfig,\n  ISplashScreen,\n} from '../../types/game.types';\nimport type { IInputManager } from '../../types/input.types';\n\n/**\n * Default configuration values\n */\nconst DEFAULT_CONFIG: Required<SplashScreenConfig> = {\n  timeout: 100,\n};\n\n/**\n * SplashScreen class\n *\n * Shows splash image with timeout and input handling.\n */\nexport class SplashScreen implements ISplashScreen {\n  // Public readonly properties\n  public get active(): boolean {\n    return this.#active;\n  }\n\n  // Private state\n  #context: CanvasRenderingContext2D;\n  #inputManager: IInputManager;\n  #config: Required<SplashScreenConfig>;\n  #active: boolean = false;\n  #counter: number = 0;\n\n  /**\n   * Create a new splash screen\n   *\n   * @param context - Canvas 2D rendering context\n   * @param inputManager - Input manager for keyboard/mouse state\n   * @param config - Optional configuration (uses defaults if not provided)\n   */\n  constructor(\n    context: CanvasRenderingContext2D,\n    inputManager: IInputManager,\n    config?: SplashScreenConfig\n  ) {\n    this.#context = context;\n    this.#inputManager = inputManager;\n    this.#config = { ...DEFAULT_CONFIG, ...config };\n  }\n\n  /**\n   * Show the splash screen\n   *\n   * Displays the splash image centered on screen.\n   *\n   * @param image - Splash screen image\n   * @param gameWidth - Current game width\n   * @param gameHeight - Current game height\n   */\n  public show(\n    image: HTMLImageElement,\n    gameWidth: number,\n    gameHeight: number\n  ): void {\n    this.#active = true;\n    this.#counter = 0;\n\n    // Center image\n    const x = gameWidth / 2 - image.width / 2;\n    const y = gameHeight / 2 - image.height / 2;\n\n    this.#context.drawImage(image, x, y);\n  }\n\n  /**\n   * Listen for user input to dismiss\n   *\n   * Called each frame while splash is active.\n   * Dismisses on mouse1, space, or timeout.\n   *\n   * @param onDismiss - Callback when user dismisses or timeout expires\n   */\n  public listen(onDismiss: () => void): void {\n    if (!this.#active) {\n      return;\n    }\n\n    this.#counter++;\n\n    // Check for dismiss input or timeout\n    if (\n      this.#inputManager.isKeyPressed('mouse1') ||\n      this.#inputManager.isKeyPressed('space') ||\n      this.#counter > this.#config.timeout\n    ) {\n      onDismiss();\n    }\n  }\n\n  /**\n   * Clear and hide the splash screen\n   *\n   * @param gameWidth - Current game width\n   * @param gameHeight - Current game height\n   */\n  public clear(gameWidth: number, gameHeight: number): void {\n    this.#active = false;\n    this.#counter = 0;\n    this.#context.clearRect(0, 0, gameWidth, gameHeight);\n  }\n}\n\n/**\n * Create a new splash screen\n *\n * Factory function for convenient instantiation.\n *\n * @param context - Canvas 2D rendering context\n * @param inputManager - Input manager\n * @param config - Optional configuration\n * @returns New SplashScreen instance\n */\nexport function createSplashScreen(\n  context: CanvasRenderingContext2D,\n  inputManager: IInputManager,\n  config?: SplashScreenConfig\n): ISplashScreen {\n  return new SplashScreen(context, inputManager, config);\n}\n","/**\n * End Screen\n *\n * Displays the game over screen with final scores.\n *\n * Migrated from EndScreen function in Game.js with improvements:\n * - Class-based with proper encapsulation\n * - Dependency injection for input manager\n * - Configurable styling\n * - Callback pattern for dismiss action\n * - Type-safe configuration\n */\n\nimport type {\n  EndScreenConfig,\n  IEndScreen,\n  PlayerScore,\n} from '../../types/game.types';\nimport type { IInputManager } from '../../types/input.types';\n\n/**\n * Default configuration values\n */\nconst DEFAULT_CONFIG: Required<EndScreenConfig> = {\n  waitTime: 100,\n  fontSize: 30,\n  fontFamily: 'Sans-Serif',\n  fontWeight: 'bold',\n};\n\n/**\n * EndScreen class\n *\n * Shows end game image and final player scores.\n */\nexport class EndScreen implements IEndScreen {\n  // Public readonly properties\n  public get active(): boolean {\n    return this.#active;\n  }\n\n  // Private state\n  #context: CanvasRenderingContext2D;\n  #inputManager: IInputManager;\n  #config: Required<EndScreenConfig>;\n  #active: boolean = false;\n  #counter: number = 0;\n\n  /**\n   * Create a new end screen\n   *\n   * @param context - Canvas 2D rendering context\n   * @param inputManager - Input manager for keyboard/mouse state\n   * @param config - Optional configuration (uses defaults if not provided)\n   */\n  constructor(\n    context: CanvasRenderingContext2D,\n    inputManager: IInputManager,\n    config?: EndScreenConfig\n  ) {\n    this.#context = context;\n    this.#inputManager = inputManager;\n    this.#config = { ...DEFAULT_CONFIG, ...config };\n  }\n\n  /**\n   * Show the end game screen with final scores\n   *\n   * Displays end game image and player scores.\n   *\n   * @param image - End game image\n   * @param scores - Player scores to display\n   * @param gameWidth - Current game width\n   * @param gameHeight - Current game height\n   */\n  public show(\n    image: HTMLImageElement,\n    scores: PlayerScore[],\n    gameWidth: number,\n    gameHeight: number\n  ): void {\n    this.#active = true;\n    this.#counter = 0;\n\n    // Draw end game image\n    const imgX = gameWidth / 2 - image.width / 2;\n    const imgY = (gameHeight * 5) / 6 - image.height;\n    this.#context.drawImage(image, imgX, imgY);\n\n    // Draw player scores\n    this.#drawScores(scores, gameWidth, gameHeight);\n  }\n\n  /**\n   * Listen for user input to return to select screen\n   *\n   * Called each frame while end screen is active.\n   * Requires wait time to expire before accepting input.\n   *\n   * @param onDismiss - Callback when user presses space\n   */\n  public listen(onDismiss: () => void): void {\n    if (!this.#active) {\n      return;\n    }\n\n    this.#counter++;\n\n    // Check for space after wait time\n    if (\n      this.#inputManager.isKeyPressed('space') &&\n      this.#counter > this.#config.waitTime\n    ) {\n      onDismiss();\n    }\n  }\n\n  /**\n   * Clear and hide the end screen\n   *\n   * @param gameWidth - Current game width\n   * @param gameHeight - Current game height\n   */\n  public clear(gameWidth: number, gameHeight: number): void {\n    this.#active = false;\n    this.#counter = 0;\n    this.#context.clearRect(0, 0, gameWidth, gameHeight);\n  }\n\n  /**\n   * Draw player scores\n   *\n   * Renders each player's final score in their color.\n   *\n   * @param scores - Player scores to display\n   * @param gameWidth - Current game width\n   * @param gameHeight - Current game height\n   */\n  #drawScores(\n    scores: PlayerScore[],\n    gameWidth: number,\n    gameHeight: number\n  ): void {\n    this.#context.save();\n\n    // Set font properties\n    this.#context.font = `${this.#config.fontWeight} ${this.#config.fontSize}px ${this.#config.fontFamily}`;\n    this.#context.textAlign = 'right';\n\n    // Calculate total players (including those not in game)\n    // Use 6 as default for consistent spacing\n    const totalPlayers = 6;\n\n    // Draw each player's score\n    for (let i = 0; i < scores.length; i++) {\n      const player = scores[i];\n      if (!player) continue;\n\n      const x = gameWidth / 2;\n      const y = ((gameHeight * 4) / 6 / totalPlayers) * i + 80;\n\n      this.#context.fillStyle = player.color;\n      this.#context.fillText(player.score.toString(), x, y);\n    }\n\n    this.#context.restore();\n  }\n}\n\n/**\n * Create a new end screen\n *\n * Factory function for convenient instantiation.\n *\n * @param context - Canvas 2D rendering context\n * @param inputManager - Input manager\n * @param config - Optional configuration\n * @returns New EndScreen instance\n */\nexport function createEndScreen(\n  context: CanvasRenderingContext2D,\n  inputManager: IInputManager,\n  config?: EndScreenConfig\n): IEndScreen {\n  return new EndScreen(context, inputManager, config);\n}\n","/**\n * ScoreBoard Component\n *\n * Manages and displays the player scoreboard in the game.\n * Shows all player scores in their respective colors on a dedicated canvas layer.\n *\n * Migrated from Score.js with improvements:\n * - Dependency injection for canvas context\n * - No global game object dependency\n * - Configurable display options\n * - Proper TypeScript types\n * - Resolved dimension inconsistencies\n */\n\nimport type { Player, ScoreConfig, IScoreBoard } from '../../types/score.types';\n\n/**\n * Maximum height for clearing the scoreboard\n * Generous height to ensure all content is cleared regardless of game size\n */\nconst MAX_CLEAR_HEIGHT = 1000;\n\n/**\n * Default configuration values\n */\nconst DEFAULT_CONFIG: Required<ScoreConfig> = {\n  width: 150,\n  fontSize: 75,\n  fontFamily: 'Sans-Serif',\n  fontStyle: 'italic',\n  backgroundColor: '#3c3c3c',\n  textAlign: 'right',\n};\n\n/**\n * ScoreBoard class\n *\n * Renders and manages the game scoreboard.\n * Displays player scores in their colors with configurable styling.\n */\nexport class ScoreBoard implements IScoreBoard {\n  // Private fields\n  #context: CanvasRenderingContext2D;\n  #config: Required<ScoreConfig>;\n\n  /**\n   * Create a new scoreboard\n   *\n   * @param context - Canvas 2D rendering context for drawing\n   * @param config - Optional configuration (uses defaults if not provided)\n   */\n  constructor(context: CanvasRenderingContext2D, config?: ScoreConfig) {\n    this.#context = context;\n    this.#config = { ...DEFAULT_CONFIG, ...config };\n  }\n\n  /**\n   * Get the width of the scoreboard panel\n   */\n  public get width(): number {\n    return this.#config.width;\n  }\n\n  /**\n   * Draw the complete scoreboard\n   *\n   * Renders the background and all player scores.\n   * Scores are positioned vertically based on player count.\n   *\n   * @param players - Array of players to display\n   * @param gameHeight - Current game canvas height for positioning\n   */\n  public draw(players: Player[], gameHeight: number): void {\n    // Clear previous scoreboard\n    this.clear();\n\n    // Draw background panel\n    this.#drawBackground(gameHeight);\n\n    // Draw player scores\n    this.#drawPlayerScores(players, gameHeight);\n  }\n\n  /**\n   * Increment scores when a player dies\n   *\n   * Implements last-man-standing scoring:\n   * When a player dies, all OTHER living players receive a point.\n   *\n   * Note: This method mutates the player array but does NOT automatically\n   * redraw the scoreboard. Call draw() afterward to update the display.\n   *\n   * @param deadPlayerName - Name of the player who died\n   * @param players - Array of all players (will be mutated)\n   *\n   * @example\n   * ```typescript\n   * scoreBoard.incrementScores('red', players);\n   * scoreBoard.draw(players, gameHeight); // Don't forget to redraw!\n   * ```\n   */\n  public incrementScores(deadPlayerName: string, players: readonly Player[]): void {\n    // Award points to all living players except the one who died\n    for (const player of players) {\n      if (player.name !== deadPlayerName && !player.dead) {\n        player.score++;\n      }\n    }\n  }\n\n  /**\n   * Clear the scoreboard canvas area\n   *\n   * Clears the entire scoreboard region.\n   * Uses a generous height to ensure all content is cleared.\n   */\n  public clear(): void {\n    this.#context.clearRect(0, 0, this.#config.width, MAX_CLEAR_HEIGHT);\n  }\n\n  /**\n   * Draw the background panel\n   *\n   * Renders a solid color rectangle as the scoreboard background.\n   *\n   * @param gameHeight - Current game canvas height\n   */\n  #drawBackground(gameHeight: number): void {\n    this.#context.save();\n\n    this.#context.fillStyle = this.#config.backgroundColor;\n    this.#context.fillRect(0, 0, this.#config.width, gameHeight);\n\n    this.#context.restore();\n  }\n\n  /**\n   * Draw all player scores\n   *\n   * Renders each player's score in their color.\n   * Positions are calculated to distribute players evenly.\n   *\n   * @param players - Array of players to display\n   * @param gameHeight - Current game canvas height for positioning\n   */\n  #drawPlayerScores(players: Player[], gameHeight: number): void {\n    if (players.length === 0) {\n      return;\n    }\n\n    this.#context.save();\n\n    // Set font properties\n    this.#context.font = `${this.#config.fontStyle} ${this.#config.fontSize}px ${this.#config.fontFamily}`;\n    this.#context.textAlign = this.#config.textAlign;\n\n    const totalPlayers = players.length;\n\n    // Draw each player's score\n    for (let i = 0; i < players.length; i++) {\n      const player = players[i];\n      if (!player) continue; // Type guard for array access\n\n      const position = this.#calculatePlayerPosition(i, totalPlayers, gameHeight);\n\n      this.#context.fillStyle = player.color;\n      this.#context.fillText(player.score.toString(), position.x, position.y);\n    }\n\n    this.#context.restore();\n  }\n\n  /**\n   * Calculate the position for a player's score\n   *\n   * Positions are distributed vertically based on player index.\n   * Horizontal position is 3/4 of the scoreboard width with padding.\n   *\n   * @param index - Player index in the array\n   * @param totalPlayers - Total number of players\n   * @param gameHeight - Current game canvas height\n   * @returns Position coordinates {x, y}\n   */\n  #calculatePlayerPosition(\n    index: number,\n    totalPlayers: number,\n    gameHeight: number\n  ): { x: number; y: number } {\n    // Original formula: x = width*3/4 - 10, y = height*0.9 * i/totalPlayers + 80\n    const x = (this.#config.width * 3) / 4 - 10;\n    const y = (gameHeight * 0.9 * index) / totalPlayers + 80;\n\n    return { x, y };\n  }\n}\n\n/**\n * Create a new scoreboard instance\n *\n * Factory function for convenient instantiation.\n *\n * @param context - Canvas 2D rendering context\n * @param config - Optional configuration\n * @returns New ScoreBoard instance\n */\nexport function createScoreBoard(\n  context: CanvasRenderingContext2D,\n  config?: ScoreConfig\n): IScoreBoard {\n  return new ScoreBoard(context, config);\n}\n","/**\n * FPS Counter\n *\n * Calculates and displays frames per second (FPS) for performance monitoring.\n * Migrated from Fps.js with improvements:\n * - Uses performance.now() for better precision\n * - Dependency injection for canvas context\n * - Configurable display options\n * - Proper TypeScript types\n * - Canvas state preservation\n */\n\nimport type { FpsConfig, IFpsCounter } from '../types/fps.types';\n\n/**\n * Default configuration values\n */\nconst DEFAULT_CONFIG: Required<FpsConfig> = {\n  updateThrottle: 50,\n  offsetX: 35,\n  offsetY: 10,\n  fontSize: 9,\n  fontFamily: 'Verdana',\n  color: '#888',\n};\n\n/**\n * FPS Counter class\n *\n * Tracks and displays the current frame rate of the game.\n * Updates are throttled to reduce rendering overhead.\n */\nexport class FpsCounter implements IFpsCounter {\n  // Private fields\n  #context: CanvasRenderingContext2D;\n  #config: Required<FpsConfig>;\n  #currentFps: number = 0;\n  #lastUpdateTime: number = performance.now();\n  #frameCount: number = 0;\n\n  /**\n   * Create a new FPS counter\n   *\n   * @param context - Canvas 2D rendering context for drawing\n   * @param config - Optional configuration (uses defaults if not provided)\n   */\n  constructor(context: CanvasRenderingContext2D, config?: FpsConfig) {\n    this.#context = context;\n    this.#config = { ...DEFAULT_CONFIG, ...config };\n  }\n\n  /**\n   * Get the current FPS value\n   */\n  public get currentFps(): number {\n    return this.#currentFps;\n  }\n\n  /**\n   * Update the FPS calculation\n   *\n   * Should be called once per frame in the game loop.\n   * Calculates FPS based on time delta since last update.\n   */\n  public update(): void {\n    const currentTime = performance.now();\n    this.#currentFps = this.#calculateFps(currentTime);\n    this.#lastUpdateTime = currentTime;\n  }\n\n  /**\n   * Draw the FPS counter to the canvas\n   *\n   * Drawing is throttled based on updateThrottle config to reduce overhead.\n   * Only draws when shouldDraw is true.\n   *\n   * @param shouldDraw - Whether the FPS counter should be displayed\n   * @param gameWidth - Current game canvas width (for positioning)\n   * @param gameHeight - Current game canvas height (for positioning)\n   */\n  public draw(shouldDraw: boolean, gameWidth: number, gameHeight: number): void {\n    if (!shouldDraw) {\n      return;\n    }\n\n    this.#frameCount++;\n\n    // Throttle drawing to reduce overhead\n    if (this.#frameCount > this.#config.updateThrottle) {\n      this.#frameCount = 0;\n      this.#drawFpsText(gameWidth, gameHeight);\n    }\n  }\n\n  /**\n   * Reset the FPS counter state\n   *\n   * Useful when restarting the game or changing game states.\n   */\n  public reset(): void {\n    this.#currentFps = 0;\n    this.#lastUpdateTime = performance.now();\n    this.#frameCount = 0;\n  }\n\n  /**\n   * Calculate FPS from time delta\n   *\n   * @param currentTime - Current timestamp from performance.now()\n   * @returns Calculated FPS value (bounded to prevent Infinity)\n   */\n  #calculateFps(currentTime: number): number {\n    const deltaMs = currentTime - this.#lastUpdateTime;\n\n    // Prevent division by zero or very small values\n    if (deltaMs <= 0) {\n      return this.#currentFps; // Return previous value if delta is invalid\n    }\n\n    const deltaSeconds = deltaMs / 1000;\n    const fps = 1 / deltaSeconds;\n\n    // Bound FPS to reasonable range (0-999)\n    return Math.min(Math.round(fps), 999);\n  }\n\n  /**\n   * Draw the FPS text to the canvas\n   *\n   * Renders in the bottom-right corner with configurable offset.\n   * Preserves canvas state to avoid affecting other rendering.\n   *\n   * @param gameWidth - Current game canvas width\n   * @param gameHeight - Current game canvas height\n   */\n  #drawFpsText(gameWidth: number, gameHeight: number): void {\n    const x = gameWidth - this.#config.offsetX;\n    const y = gameHeight - this.#config.offsetY;\n\n    // Clear previous FPS text (before save to avoid being affected by transforms)\n    this.#context.clearRect(x - 2, y - 10, 40, 15);\n\n    // Save canvas state to avoid polluting global state\n    this.#context.save();\n\n    // Set text rendering properties\n    this.#context.textAlign = 'left';\n    this.#context.font = `${this.#config.fontSize}px ${this.#config.fontFamily}`;\n    this.#context.fillStyle = this.#config.color;\n\n    // Draw FPS text\n    this.#context.fillText(`fps:${this.#currentFps}`, x, y);\n\n    // Restore canvas state\n    this.#context.restore();\n  }\n}\n\n/**\n * Create a new FPS counter instance\n *\n * Factory function for convenient instantiation.\n *\n * @param context - Canvas 2D rendering context\n * @param config - Optional configuration\n * @returns New FpsCounter instance\n */\nexport function createFpsCounter(\n  context: CanvasRenderingContext2D,\n  config?: FpsConfig\n): IFpsCounter {\n  return new FpsCounter(context, config);\n}\n","/**\n * Player Selector Screen\n *\n * Manages the player selection screen where players toggle their readiness\n * for a game round using their control keys.\n *\n * Migrated from SelectPlayers.js with improvements:\n * - Dependency injection for all external dependencies\n * - KeyboardManager integration (replaces global KEY_STATUS)\n * - Callback pattern for game start (replaces game.start() call)\n * - Configurable layout options\n * - Image validation before drawing\n * - Proper TypeScript types\n */\n\nimport type {\n  PlayerTemplate,\n  ImageRepository,\n  PlayerSelectorConfig,\n  IPlayerSelector,\n} from '../../types/player.types';\nimport type { IInputManager } from '../../types/input.types';\n\n/**\n * Default configuration values\n */\nconst DEFAULT_CONFIG: Required<PlayerSelectorConfig> = {\n  keyLabelXRatio: 1 / 5,\n  iconOffsetX: 220,\n  baseY: 80,\n  verticalSpacingRatio: 0.6,\n  fontSize: 20,\n  fontFamily: 'Courier',\n  fontWeight: 'bold',\n  instructionYRatio: 7 / 8,\n  instructionText: 'Press space to start',\n  instructionColor: 'white',\n};\n\n/**\n * PlayerSelector class\n *\n * Displays a screen where players can join/leave the next round\n * by pressing their assigned control keys.\n */\nexport class PlayerSelector implements IPlayerSelector {\n  // Private fields\n  #context: CanvasRenderingContext2D;\n  #inputManager: IInputManager;\n  #config: Required<PlayerSelectorConfig>;\n  #active: boolean = false;\n\n  /**\n   * Create a new player selector screen\n   *\n   * @param context - Canvas 2D rendering context for drawing\n   * @param inputManager - Input manager for keyboard state\n   * @param config - Optional configuration (uses defaults if not provided)\n   */\n  constructor(\n    context: CanvasRenderingContext2D,\n    inputManager: IInputManager,\n    config?: PlayerSelectorConfig\n  ) {\n    this.#context = context;\n    this.#inputManager = inputManager;\n    this.#config = { ...DEFAULT_CONFIG, ...config };\n  }\n\n  /**\n   * Get whether the selector screen is currently active\n   */\n  public get active(): boolean {\n    return this.#active;\n  }\n\n  /**\n   * Show the player selection screen\n   *\n   * Displays player control keys and instructions.\n   *\n   * @param playerTemplates - Array of player templates to display\n   * @param gameWidth - Current game canvas width\n   * @param gameHeight - Current game canvas height\n   */\n  public show(\n    playerTemplates: PlayerTemplate[],\n    gameWidth: number,\n    gameHeight: number\n  ): void {\n    this.#active = true;\n\n    // Show player control keys\n    this.#showPlayerControls(playerTemplates, gameWidth, gameHeight);\n\n    // Show instructions\n    this.#showInstructions(gameWidth, gameHeight);\n  }\n\n  /**\n   * Listen for player input\n   *\n   * Monitors keyboard input to toggle player ready states.\n   * When space is pressed, starts the game if any player is ready.\n   *\n   * Note: This method mutates the playerTemplates array by setting\n   * the `ready` property on each player.\n   *\n   * @param playerTemplates - Array of player templates (will be mutated)\n   * @param imageRepo - Image repository for player sprites\n   * @param gameWidth - Current game canvas width\n   * @param gameHeight - Current game canvas height\n   * @param onStart - Callback to invoke when game should start\n   */\n  public listen(\n    playerTemplates: PlayerTemplate[],\n    imageRepo: ImageRepository,\n    gameWidth: number,\n    gameHeight: number,\n    onStart: () => void\n  ): void {\n    // Handle player ready state toggles\n    this.#handlePlayerInput(playerTemplates, imageRepo, gameWidth, gameHeight);\n\n    // Handle game start input\n    this.#handleStartInput(playerTemplates, onStart);\n  }\n\n  /**\n   * Clear the player selection screen\n   *\n   * Resets all players to not ready, deactivates the screen,\n   * and clears the canvas.\n   *\n   * @param playerTemplates - Array of player templates (will be mutated)\n   * @param gameWidth - Current game canvas width\n   * @param gameHeight - Current game canvas height\n   */\n  public clear(\n    playerTemplates: PlayerTemplate[],\n    gameWidth: number,\n    gameHeight: number\n  ): void {\n    // Reset all players to not ready\n    for (const player of playerTemplates) {\n      player.ready = false;\n    }\n\n    // Deactivate screen\n    this.#active = false;\n\n    // Clear canvas\n    this.#context.clearRect(0, 0, gameWidth, gameHeight);\n  }\n\n  /**\n   * Show player controls\n   *\n   * Displays the control keys for each player in their color.\n   *\n   * @param playerTemplates - Array of player templates\n   * @param gameWidth - Current game canvas width\n   * @param gameHeight - Current game canvas height\n   */\n  #showPlayerControls(\n    playerTemplates: PlayerTemplate[],\n    gameWidth: number,\n    gameHeight: number\n  ): void {\n    this.#context.save();\n\n    // Set font properties\n    this.#context.font = `${this.#config.fontWeight} ${this.#config.fontSize}px ${this.#config.fontFamily}`;\n    this.#context.textAlign = 'left';\n\n    for (let i = 0; i < playerTemplates.length; i++) {\n      const player = playerTemplates[i];\n      if (!player) continue;\n\n      const position = this.#calculatePlayerPosition(\n        i,\n        playerTemplates.length,\n        gameWidth,\n        gameHeight\n      );\n\n      // Draw control keys in player color\n      this.#context.fillStyle = player.color;\n      this.#context.fillText(\n        `(${player.left} ${player.right})`,\n        position.x,\n        position.y\n      );\n    }\n\n    this.#context.restore();\n  }\n\n  /**\n   * Show instructions text\n   *\n   * Displays centered instructions at the bottom of the screen.\n   *\n   * @param gameWidth - Current game canvas width\n   * @param gameHeight - Current game canvas height\n   */\n  #showInstructions(gameWidth: number, gameHeight: number): void {\n    this.#context.save();\n\n    this.#context.fillStyle = this.#config.instructionColor;\n    this.#context.textAlign = 'center';\n    this.#context.fillText(\n      this.#config.instructionText,\n      gameWidth / 2,\n      gameHeight * this.#config.instructionYRatio\n    );\n\n    this.#context.restore();\n  }\n\n  /**\n   * Handle player input for toggling ready states\n   *\n   * Monitors each player's left/right keys:\n   * - Left key: Set player ready and show icon\n   * - Right key: Set player not ready and hide icon\n   *\n   * @param playerTemplates - Array of player templates (will be mutated)\n   * @param imageRepo - Image repository for player sprites\n   * @param gameWidth - Current game canvas width\n   * @param gameHeight - Current game canvas height\n   */\n  #handlePlayerInput(\n    playerTemplates: PlayerTemplate[],\n    imageRepo: ImageRepository,\n    gameWidth: number,\n    gameHeight: number\n  ): void {\n    for (let i = 0; i < playerTemplates.length; i++) {\n      const player = playerTemplates[i];\n      if (!player) continue;\n\n      const position = this.#calculatePlayerPosition(\n        i,\n        playerTemplates.length,\n        gameWidth,\n        gameHeight\n      );\n\n      // Get player image from repository\n      const image = imageRepo[player.name];\n\n      // Validate image exists and is loaded\n      if (!image || !this.#isImageValid(image)) {\n        continue;\n      }\n\n      // Calculate icon position\n      const iconX = position.x + this.#config.iconOffsetX;\n      const iconY = position.y - image.height;\n\n      // Check left key - set player ready\n      if (this.#inputManager.isKeyPressed(player.left)) {\n        player.ready = true;\n        this.#context.drawImage(image, iconX, iconY);\n      }\n      // Check right key - set player not ready\n      else if (this.#inputManager.isKeyPressed(player.right)) {\n        player.ready = false;\n        this.#context.clearRect(iconX, iconY, image.width, image.height);\n      }\n    }\n  }\n\n  /**\n   * Handle start input\n   *\n   * If space is pressed and at least one player is ready,\n   * invokes the start callback.\n   *\n   * @param playerTemplates - Array of player templates\n   * @param onStart - Callback to invoke when starting\n   */\n  #handleStartInput(\n    playerTemplates: PlayerTemplate[],\n    onStart: () => void\n  ): void {\n    // Check if space is pressed\n    if (!this.#inputManager.isKeyPressed('space')) {\n      return;\n    }\n\n    // Check if any player is ready\n    for (const player of playerTemplates) {\n      if (player.ready) {\n        onStart();\n        break; // Only start once\n      }\n    }\n  }\n\n  /**\n   * Validate that an image is loaded and ready to draw\n   *\n   * @param image - Image to validate\n   * @returns True if image is valid and loaded\n   */\n  #isImageValid(image: HTMLImageElement | undefined): boolean {\n    if (!image) {\n      return false;\n    }\n\n    // Check if image has loaded\n    return image.complete && image.naturalWidth > 0;\n  }\n\n  /**\n   * Calculate the position for a player's controls\n   *\n   * Positions are distributed vertically based on player count.\n   *\n   * @param index - Player index in the array\n   * @param totalPlayers - Total number of players\n   * @param gameWidth - Current game canvas width\n   * @param gameHeight - Current game canvas height\n   * @returns Position coordinates {x, y}\n   */\n  #calculatePlayerPosition(\n    index: number,\n    totalPlayers: number,\n    gameWidth: number,\n    gameHeight: number\n  ): { x: number; y: number } {\n    const x = gameWidth * this.#config.keyLabelXRatio;\n    const y =\n      ((gameHeight * this.#config.verticalSpacingRatio) / totalPlayers) * index +\n      this.#config.baseY;\n\n    return { x, y };\n  }\n}\n\n/**\n * Create a new player selector instance\n *\n * Factory function for convenient instantiation.\n *\n * @param context - Canvas 2D rendering context\n * @param inputManager - Input manager for keyboard state\n * @param config - Optional configuration\n * @returns New PlayerSelector instance\n */\nexport function createPlayerSelector(\n  context: CanvasRenderingContext2D,\n  inputManager: IInputManager,\n  config?: PlayerSelectorConfig\n): IPlayerSelector {\n  return new PlayerSelector(context, inputManager, config);\n}\n","/**\n * Game Configuration Types and Presets\n *\n * Defines the configuration structure for different game modes (classic, agility, strategy).\n * Each configuration controls game mechanics like speed, turning rate, hole frequency, etc.\n */\n\n/**\n * Configuration for a single game preset\n */\nexport interface GameConfiguration {\n  /** Number of rounds until game ends */\n  maxRounds: number;\n\n  /** Radius of the player trail in pixels */\n  size: number;\n\n  /** Linear movement speed in pixels per frame */\n  speed: number;\n\n  /** Angular turning speed in degrees per frame */\n  curveSpeed: number;\n\n  /** Base frequency of holes in frames between holes */\n  holeRate: number;\n\n  /** Random variation of hole frequency (frames) */\n  holeRateRnd: number;\n\n  /** Base duration of each hole in frames */\n  holeSize: number;\n\n  /** Random variation of hole duration (frames) */\n  holeSizeRnd: number;\n}\n\n/**\n * Available game preset names\n */\nexport type PresetName = 'classic' | 'agility' | 'strategy';\n\n/**\n * Game mode presets with different difficulty and play styles\n *\n * - **classic**: Balanced gameplay with medium speed and moderate holes\n * - **agility**: Fast-paced, reflex-based with high speed and many rounds\n * - **strategy**: Slow, methodical with frequent holes and few rounds\n *\n * @readonly Immutable configuration object\n */\nexport const configurations = {\n  /**\n   * Classic mode: Balanced gameplay, original Zatacka experience\n   */\n  classic: {\n    maxRounds: 15,\n    size: 3,\n    speed: 1.6,\n    curveSpeed: 2,\n    holeRate: 450,\n    holeRateRnd: 200,\n    holeSize: 11,\n    holeSizeRnd: 3,\n  },\n\n  /**\n   * Agility mode: High-speed, reflex-based, longer games\n   */\n  agility: {\n    maxRounds: 20,\n    size: 4,\n    speed: 3,\n    curveSpeed: 3.5,\n    holeRate: 400,\n    holeRateRnd: 200,\n    holeSize: 9,\n    holeSizeRnd: 3,\n  },\n\n  /**\n   * Strategy mode: Slow, tactical, short games with frequent holes\n   */\n  strategy: {\n    maxRounds: 5,\n    size: 3.2,\n    speed: 1,\n    curveSpeed: 2,\n    holeRate: 220,\n    holeRateRnd: 100,\n    holeSize: 14,\n    holeSizeRnd: 1,\n  },\n} as const satisfies Record<PresetName, GameConfiguration>;\n\n/**\n * Get a configuration by preset name with type safety\n *\n * @param preset - Name of the preset to retrieve\n * @returns The game configuration for the specified preset, or undefined if not found\n */\nexport function getConfiguration(preset: string): GameConfiguration | undefined {\n  if (isValidPreset(preset)) {\n    return configurations[preset];\n  }\n  return undefined;\n}\n\n/**\n * Type guard to check if a string is a valid preset name\n *\n * @param preset - String to check\n * @returns True if the string is a valid PresetName\n */\nexport function isValidPreset(preset: string): preset is PresetName {\n  return preset in configurations;\n}\n\n/**\n * Get all available preset names\n *\n * @returns Array of all valid preset names\n */\nexport function getAllPresetNames(): PresetName[] {\n  return Object.keys(configurations) as PresetName[];\n}\n\n/**\n * Validate that a configuration object has all required properties with valid values\n *\n * Use this when loading configurations from external sources (e.g., JSON files, API responses).\n * Not needed for TypeScript-defined configurations which are already type-checked at compile time.\n *\n * @param config - Configuration object to validate\n * @returns True if all properties are numbers greater than 0\n */\nexport function validateConfiguration(config: GameConfiguration): boolean {\n  return (\n    typeof config.maxRounds === 'number' &&\n    config.maxRounds > 0 &&\n    typeof config.size === 'number' &&\n    config.size > 0 &&\n    typeof config.speed === 'number' &&\n    config.speed > 0 &&\n    typeof config.curveSpeed === 'number' &&\n    config.curveSpeed > 0 &&\n    typeof config.holeRate === 'number' &&\n    config.holeRate > 0 &&\n    typeof config.holeRateRnd === 'number' &&\n    config.holeRateRnd >= 0 &&\n    typeof config.holeSize === 'number' &&\n    config.holeSize > 0 &&\n    typeof config.holeSizeRnd === 'number' &&\n    config.holeSizeRnd >= 0\n  );\n}\n\n// Default export for backward compatibility\nexport default configurations;\n","/**\n * Advanced Settings Component\n *\n * Manages the advanced game settings UI, allowing users to toggle between\n * classic presets and custom configurations.\n *\n * Migrated from Advanced.js with improvements:\n * - Lazy initialization pattern (no auto-init in constructor)\n * - Dependency injection for DOM elements (no direct DOM queries)\n * - Event handler cleanup to prevent memory leaks\n * - Type-safe configuration handling\n * - Integration with gameConfigurations.ts types\n * - Input validation before returning configuration\n */\n\nimport {\n  configurations,\n  validateConfiguration,\n  type GameConfiguration,\n  type PresetName,\n} from '../../config/gameConfigurations';\nimport type {\n  AdvancedSettingsConfig,\n  AdvancedSettingsElements,\n  IAdvancedSettings,\n} from '../../types/settings.types';\n\n/**\n * Default configuration values\n */\nconst DEFAULT_CONFIG: Required<AdvancedSettingsConfig> = {\n  defaultPreset: 'classic',\n  buttonClassicText: 'Classic',\n  buttonAdvancedText: 'Advanced',\n};\n\n/**\n * AdvancedSettings class\n *\n * Controls the advanced settings UI panel, preset selection,\n * and configuration value editing.\n */\nexport class AdvancedSettings implements IAdvancedSettings {\n  // Private fields\n  #config: Required<AdvancedSettingsConfig>;\n  #elements?: AdvancedSettingsElements;\n  #active: boolean = false;\n  #boundHandlers: Map<string, EventListener> = new Map();\n\n  /**\n   * Create a new advanced settings controller\n   *\n   * @param config - Optional configuration (uses defaults if not provided)\n   */\n  constructor(config?: AdvancedSettingsConfig) {\n    this.#config = { ...DEFAULT_CONFIG, ...config };\n  }\n\n  /**\n   * Get whether advanced settings mode is currently active\n   */\n  public get active(): boolean {\n    return this.#active;\n  }\n\n  /**\n   * Initialize the advanced settings controller\n   *\n   * Sets up event handlers and loads the default preset.\n   * Must be called before using other methods.\n   *\n   * @param elements - DOM elements required by the controller\n   */\n  public initialize(elements: AdvancedSettingsElements): void {\n    this.#elements = elements;\n\n    // Load default preset into form\n    this.setPreset(this.#config.defaultPreset);\n\n    // Set up event handlers\n    this.#setupEventHandlers();\n  }\n\n  /**\n   * Show the advanced settings panel\n   *\n   * Makes the panel visible by setting display style to 'block'.\n   */\n  public show(): void {\n    if (!this.#elements) {\n      throw new Error('AdvancedSettings not initialized. Call initialize() first.');\n    }\n\n    this.#elements.advancedPanel.style.display = 'block';\n  }\n\n  /**\n   * Hide the advanced settings panel\n   *\n   * Makes the panel invisible by setting display style to 'none'.\n   */\n  public hide(): void {\n    if (!this.#elements) {\n      throw new Error('AdvancedSettings not initialized. Call initialize() first.');\n    }\n\n    this.#elements.advancedPanel.style.display = 'none';\n  }\n\n  /**\n   * Get the current configuration from form inputs\n   *\n   * Collects all input values, parses them, and validates the result.\n   *\n   * @returns Current game configuration\n   * @throws Error if configuration is invalid or contains NaN values\n   */\n  public getConfiguration(): GameConfiguration {\n    if (!this.#elements) {\n      throw new Error('AdvancedSettings not initialized. Call initialize() first.');\n    }\n\n    const inputs = this.#elements.inputs;\n\n    // Parse input values\n    const maxRounds = parseFloat(inputs.maxRounds.value);\n    const size = parseFloat(inputs.size.value);\n    const speed = parseFloat(inputs.speed.value);\n    const curveSpeed = parseFloat(inputs.curveSpeed.value);\n    const holeRate = parseFloat(inputs.holeRate.value);\n    const holeRateRnd = parseFloat(inputs.holeRateRnd.value);\n    const holeSize = parseFloat(inputs.holeSize.value);\n    const holeSizeRnd = parseFloat(inputs.holeSizeRnd.value);\n\n    // Check for NaN values\n    if (isNaN(maxRounds)) throw new Error('Invalid value for maxRounds');\n    if (isNaN(size)) throw new Error('Invalid value for size');\n    if (isNaN(speed)) throw new Error('Invalid value for speed');\n    if (isNaN(curveSpeed)) throw new Error('Invalid value for curveSpeed');\n    if (isNaN(holeRate)) throw new Error('Invalid value for holeRate');\n    if (isNaN(holeRateRnd)) throw new Error('Invalid value for holeRateRnd');\n    if (isNaN(holeSize)) throw new Error('Invalid value for holeSize');\n    if (isNaN(holeSizeRnd)) throw new Error('Invalid value for holeSizeRnd');\n\n    // Collect configuration\n    const config: GameConfiguration = {\n      maxRounds,\n      size,\n      speed,\n      curveSpeed,\n      holeRate,\n      holeRateRnd,\n      holeSize,\n      holeSizeRnd,\n    };\n\n    // Validate configuration (validateConfiguration returns boolean)\n    const isValid = validateConfiguration(config);\n    if (!isValid) {\n      throw new Error('Invalid configuration values (out of valid range)');\n    }\n\n    return config;\n  }\n\n  /**\n   * Load a preset configuration into the form\n   *\n   * Populates all input fields with values from the specified preset.\n   *\n   * @param preset - Name of the preset to load\n   */\n  public setPreset(preset: PresetName): void {\n    if (!this.#elements) {\n      throw new Error('AdvancedSettings not initialized. Call initialize() first.');\n    }\n\n    const config = configurations[preset];\n    this.#populateFields(config);\n  }\n\n  /**\n   * Clean up event handlers and resources\n   *\n   * Removes all event listeners to prevent memory leaks.\n   * Should be called when the component is no longer needed.\n   */\n  public destroy(): void {\n    this.#cleanupEventHandlers();\n    this.#elements = undefined;\n  }\n\n  /**\n   * Set up all event handlers\n   *\n   * Attaches click handlers to the toggle button and preset buttons.\n   */\n  #setupEventHandlers(): void {\n    if (!this.#elements) return;\n\n    // Advanced/Classic toggle button handler\n    const toggleHandler = this.#handleAdvancedButtonClick.bind(this);\n    this.#boundHandlers.set('toggleButton', toggleHandler);\n    this.#elements.advancedButton.addEventListener('click', toggleHandler);\n\n    // Preset button handlers\n    for (const button of this.#elements.presetButtons) {\n      const preset = button.getAttribute('data-preset') as PresetName | null;\n      if (!preset) continue;\n\n      const handler = () => this.#handlePresetButtonClick(preset);\n      this.#boundHandlers.set(`preset-${preset}`, handler);\n      button.addEventListener('click', handler);\n    }\n  }\n\n  /**\n   * Clean up all event handlers\n   *\n   * Removes all attached event listeners.\n   */\n  #cleanupEventHandlers(): void {\n    if (!this.#elements) return;\n\n    // Remove toggle button handler\n    const toggleHandler = this.#boundHandlers.get('toggleButton');\n    if (toggleHandler) {\n      this.#elements.advancedButton.removeEventListener('click', toggleHandler);\n    }\n\n    // Remove preset button handlers\n    for (const button of this.#elements.presetButtons) {\n      const preset = button.getAttribute('data-preset') as PresetName | null;\n      if (!preset) continue;\n\n      const handler = this.#boundHandlers.get(`preset-${preset}`);\n      if (handler) {\n        button.removeEventListener('click', handler);\n      }\n    }\n\n    this.#boundHandlers.clear();\n  }\n\n  /**\n   * Handle click on the advanced/classic toggle button\n   *\n   * Toggles between classic mode (form hidden) and advanced mode (form visible).\n   */\n  #handleAdvancedButtonClick(): void {\n    if (!this.#elements) return;\n\n    if (this.#active) {\n      // Switch to classic mode\n      this.#active = false;\n      this.#elements.classicButton.click();\n      this.#elements.advancedButton.innerHTML = this.#config.buttonClassicText;\n      this.#elements.advancedButton.className = 'classic';\n      this.#elements.form.style.display = 'none';\n    } else {\n      // Switch to advanced mode\n      this.#active = true;\n      this.#elements.advancedButton.innerHTML = this.#config.buttonAdvancedText;\n      this.#elements.advancedButton.className = '';\n      this.#elements.form.style.display = 'block';\n    }\n  }\n\n  /**\n   * Handle click on a preset button\n   *\n   * Loads the selected preset configuration into the form.\n   *\n   * @param preset - Name of the preset to load\n   */\n  #handlePresetButtonClick(preset: PresetName): void {\n    this.setPreset(preset);\n  }\n\n  /**\n   * Populate form fields with configuration values\n   *\n   * Sets each input element's value to the corresponding configuration value.\n   *\n   * @param config - Configuration to load into the form\n   */\n  #populateFields(config: GameConfiguration): void {\n    if (!this.#elements) return;\n\n    const inputs = this.#elements.inputs;\n\n    inputs.maxRounds.value = config.maxRounds.toString();\n    inputs.size.value = config.size.toString();\n    inputs.speed.value = config.speed.toString();\n    inputs.curveSpeed.value = config.curveSpeed.toString();\n    inputs.holeRate.value = config.holeRate.toString();\n    inputs.holeRateRnd.value = config.holeRateRnd.toString();\n    inputs.holeSize.value = config.holeSize.toString();\n    inputs.holeSizeRnd.value = config.holeSizeRnd.toString();\n  }\n}\n\n/**\n * Create a new advanced settings controller\n *\n * Factory function for convenient instantiation.\n *\n * @param config - Optional configuration\n * @returns New AdvancedSettings instance\n */\nexport function createAdvancedSettings(\n  config?: AdvancedSettingsConfig\n): IAdvancedSettings {\n  return new AdvancedSettings(config);\n}\n","/**\n * Player Entity\n *\n * Represents an individual player in the game with physics, collision detection,\n * and rendering capabilities.\n *\n * Migrated from Player.js with improvements:\n * - Dependency injection for all external dependencies\n * - No global state access\n * - Type-safe configuration and dependencies\n * - Proper encapsulation with private fields\n * - FPS-adjusted physics calculations\n * - Pixel-based collision detection\n */\n\nimport type {\n  PlayerName,\n  PlayerTemplate,\n  PlayerPhysicsConfig,\n  PlayerDependencies,\n  PlayerConstants,\n  IPlayer,\n  OnPlayerDeath,\n} from '../../types/player.types';\n\n/**\n * Default constants for player behavior\n */\nconst DEFAULT_CONSTANTS: Required<PlayerConstants> = {\n  afterDieTime: 0,\n  collisionTolerance: 30,\n  startTime: 40,\n};\n\n/**\n * Player class\n *\n * Handles player physics, collision detection, trail rendering, and game state.\n */\nexport class Player implements IPlayer {\n  // Public readonly properties (from template)\n  readonly name: PlayerName;\n  readonly color: string;\n  readonly #left: string;\n  readonly #right: string;\n\n  // Public mutable properties\n  public score: number = 0;\n  public dead: boolean = false;\n\n  // Configuration\n  #size: number;\n  #speed: number;\n  #curveSpeed: number;\n  #holeRate: number;\n  #holeRateRnd: number;\n  #holeSize: number;\n  #holeSizeRnd: number;\n\n  // Dependencies\n  #context: CanvasRenderingContext2D;\n  #inputManager: { isKeyPressed(key: string): boolean };\n  #fpsProvider: { readonly currentFps: number };\n  #dimensions: { width: number; height: number; scoreWidth: number };\n\n  // Constants\n  #afterDieTime: number;\n  #collisionTolerance: number;\n  #startTime: number;\n\n  // Position and movement state\n  #x: number = 0;\n  #y: number = 0;\n  #angle: number = 0;\n\n  // Life state\n  #dying: boolean = false;\n  #afterDieCount: number = 0;\n\n  // Timing\n  #counter: number = 0;\n\n  // Hole state\n  #hole: boolean = false;\n  #holeCounter: number = 0;\n  #nextHole: number = 0;\n  #nextHoleSize: number = 0;\n\n  // Death callback\n  #onDeath?: OnPlayerDeath;\n\n  /**\n   * Create a new player\n   *\n   * @param template - Player template with name, color, and controls\n   * @param physics - Physics configuration (speed, size, holes)\n   * @param dependencies - External dependencies (context, input, fps, dimensions)\n   * @param constants - Optional behavior constants (timing, collision tolerance)\n   * @param onDeath - Optional callback when player dies\n   */\n  constructor(\n    template: PlayerTemplate,\n    physics: PlayerPhysicsConfig,\n    dependencies: PlayerDependencies,\n    constants?: PlayerConstants,\n    onDeath?: OnPlayerDeath\n  ) {\n    // Set template properties\n    this.name = template.name;\n    this.color = template.color;\n    this.#left = template.left;\n    this.#right = template.right;\n\n    // Set physics configuration\n    this.#size = physics.size;\n    this.#speed = physics.speed;\n    this.#curveSpeed = physics.curveSpeed;\n    this.#holeRate = physics.holeRate;\n    this.#holeRateRnd = physics.holeRateRnd;\n    this.#holeSize = physics.holeSize;\n    this.#holeSizeRnd = physics.holeSizeRnd;\n\n    // Set dependencies\n    this.#context = dependencies.context;\n    this.#inputManager = dependencies.inputManager;\n    this.#fpsProvider = dependencies.fpsProvider;\n    this.#dimensions = dependencies.dimensions;\n\n    // Set constants\n    const finalConstants = { ...DEFAULT_CONSTANTS, ...constants };\n    this.#afterDieTime = finalConstants.afterDieTime;\n    this.#collisionTolerance = finalConstants.collisionTolerance;\n    this.#startTime = finalConstants.startTime;\n\n    // Set death callback\n    this.#onDeath = onDeath;\n  }\n\n  /**\n   * Initialize player for a new round\n   *\n   * Resets all state variables and sets random starting position/angle.\n   */\n  public init(): void {\n    // Reset counters\n    this.#counter = 0;\n    this.#holeCounter = 0;\n    this.#afterDieCount = 0;\n\n    // Reset state\n    this.#dying = false;\n    this.#hole = false;\n    this.dead = false;\n\n    // Set random starting position\n    // Original logic: startOnCenter = false\n    const gameWidth = this.#dimensions.width - this.#dimensions.scoreWidth;\n    this.#x = (gameWidth - 100) * Math.random() + 50;\n    this.#y = (this.#dimensions.height - 100) * Math.random() + 50;\n    this.#angle = Math.random() * 360;\n\n    // Initialize hole state\n    this.#getNextHole();\n    this.#getNextHoleSize();\n  }\n\n  /**\n   * Update and draw the player\n   *\n   * Main game loop method called once per frame.\n   * Handles physics, collision detection, and rendering.\n   */\n  public draw(): void {\n    this.#counter++;\n\n    // Skip drawing during startup delay (but not on first 2 frames)\n    if (this.#counter < this.#startTime && this.#counter > 2) {\n      return;\n    }\n\n    // Check if player has been dead long enough\n    if (this.#dying && this.#afterDieCount > this.#afterDieTime) {\n      this.dead = true;\n\n      // Trigger death callback\n      if (this.#onDeath) {\n        this.#onDeath(this.name);\n      }\n\n      return;\n    }\n\n    // Increment after-die counter if dying\n    if (this.#dying) {\n      this.#afterDieCount++;\n    }\n\n    // Calculate FPS-adjusted speed\n    const fps = this.#fpsProvider.currentFps;\n    const speedMultiplier = fps && fps > 20 ? 60 / fps : 1;\n    const adjustedSpeed = this.#speed * speedMultiplier;\n    const adjustedAngSpeed = this.#curveSpeed * speedMultiplier;\n\n    // Handle input and update angle\n    if (this.#inputManager.isKeyPressed(this.#left)) {\n      this.#angle += adjustedAngSpeed;\n    } else if (this.#inputManager.isKeyPressed(this.#right)) {\n      this.#angle -= adjustedAngSpeed;\n    }\n\n    // Update position\n    const angleRad = (this.#angle * Math.PI) / 180;\n    this.#y += adjustedSpeed * Math.cos(angleRad);\n    this.#x += adjustedSpeed * Math.sin(angleRad);\n\n    // Manage hole creation\n    this.#createHole();\n\n    // Check collision and draw (only if not in a hole)\n    if (!this.#hole) {\n      if (this.#isColliding()) {\n        this.#dying = true;\n      }\n\n      this.#drawStroke();\n    }\n  }\n\n  /**\n   * Calculate next hole distance\n   *\n   * Uses random variation around the base hole rate.\n   */\n  #getNextHole(): void {\n    this.#nextHole =\n      this.#holeRate + (Math.random() * 2 - 1) * this.#holeRateRnd;\n  }\n\n  /**\n   * Calculate next hole size\n   *\n   * Uses random variation around the base hole size.\n   */\n  #getNextHoleSize(): void {\n    this.#nextHoleSize =\n      this.#holeSize + (Math.random() * 2 - 1) * this.#holeSizeRnd;\n  }\n\n  /**\n   * Draw player trail stroke\n   *\n   * Renders a circular arc at the current position.\n   */\n  #drawStroke(): void {\n    this.#context.beginPath();\n    this.#context.fillStyle = this.color;\n    this.#context.arc(this.#x, this.#y, this.#size, 0, 2 * Math.PI);\n    this.#context.fill();\n  }\n\n  /**\n   * Manage hole creation in the trail\n   *\n   * Creates gaps in the player trail at random intervals.\n   */\n  #createHole(): void {\n    this.#holeCounter++;\n\n    if (this.#holeCounter > this.#nextHole || this.#hole) {\n      this.#hole = true;\n\n      if (this.#holeCounter > this.#nextHole + this.#nextHoleSize) {\n        this.#getNextHole();\n        this.#getNextHoleSize();\n        this.#hole = false;\n        this.#holeCounter = 0;\n      }\n    }\n  }\n\n  /**\n   * Check for collisions\n   *\n   * Detects collisions with:\n   * - Canvas boundaries\n   * - Existing trails (own or other players)\n   *\n   * Uses pixel sampling at two points ahead of the player\n   * based on current angle and collision tolerance.\n   *\n   * @returns True if collision detected, false otherwise\n   */\n  #isColliding(): boolean {\n    // Check boundary collisions\n    const gameWidth = this.#dimensions.width - this.#dimensions.scoreWidth;\n    if (\n      this.#x < 0 ||\n      this.#x > gameWidth ||\n      this.#y < 0 ||\n      this.#y > this.#dimensions.height\n    ) {\n      return true;\n    }\n\n    // Check trail collisions using pixel sampling\n    const rcol = this.#size + 2;\n\n    // Sample point 1 (ahead-left)\n    const rad1 = ((this.#angle + this.#collisionTolerance) * Math.PI) / 180;\n    const y1 = Math.round(this.#y + rcol * Math.cos(rad1));\n    const x1 = Math.round(this.#x + rcol * Math.sin(rad1));\n    const p1 = this.#context.getImageData(x1, y1, 1, 1).data;\n\n    // Sample point 2 (ahead-right)\n    const rad2 = ((this.#angle - this.#collisionTolerance) * Math.PI) / 180;\n    const y2 = Math.round(this.#y + rcol * Math.cos(rad2));\n    const x2 = Math.round(this.#x + rcol * Math.sin(rad2));\n    const p2 = this.#context.getImageData(x2, y2, 1, 1).data;\n\n    // Collision if either sample point has color (non-black pixel)\n    // Check all RGB channels, not just red, to detect all colors\n    if (\n      p1[0] !== 0 ||\n      p1[1] !== 0 ||\n      p1[2] !== 0 ||\n      p2[0] !== 0 ||\n      p2[1] !== 0 ||\n      p2[2] !== 0\n    ) {\n      return true;\n    }\n\n    return false;\n  }\n}\n\n/**\n * Create a new player instance\n *\n * Factory function for convenient instantiation.\n *\n * @param template - Player template\n * @param physics - Physics configuration\n * @param dependencies - Dependencies\n * @param constants - Optional constants\n * @param onDeath - Optional death callback\n * @returns New Player instance\n */\nexport function createPlayer(\n  template: PlayerTemplate,\n  physics: PlayerPhysicsConfig,\n  dependencies: PlayerDependencies,\n  constants?: PlayerConstants,\n  onDeath?: OnPlayerDeath\n): IPlayer {\n  return new Player(template, physics, dependencies, constants, onDeath);\n}\n","/**\n * Player Manager\n *\n * Manages the collection of active players and handles round logic.\n *\n * Migrated from Players constructor in Player.js with improvements:\n * - Dependency injection for all external dependencies\n * - No global state access\n * - Type-safe configuration and dependencies\n * - Proper encapsulation with private fields\n * - Callback pattern for game events\n */\n\nimport type {\n  PlayerTemplate,\n  PlayerManagerConfig,\n  PlayerDependencies,\n  PlayerConstants,\n  IPlayer,\n  IPlayerManager,\n  OnPlayerDeath,\n} from '../../types/player.types';\nimport { createPlayer } from '../entities/Player';\n\n/**\n * Default player templates\n *\n * All 6 possible players with their colors and control keys.\n */\nconst DEFAULT_PLAYER_TEMPLATES: PlayerTemplate[] = [\n  {\n    ready: false,\n    count: 1,\n    name: 'red',\n    color: '#f82801',\n    left: '1',\n    right: 'q',\n  },\n  {\n    ready: false,\n    count: 2,\n    name: 'yellow',\n    color: '#c0c001',\n    left: 'Shift',\n    right: 'Ctrl',\n  },\n  {\n    ready: false,\n    count: 3,\n    name: 'orange',\n    color: '#f87801',\n    left: 'n',\n    right: 'm',\n  },\n  {\n    ready: false,\n    count: 4,\n    name: 'green',\n    color: '#01c801',\n    left: 'left',\n    right: 'down',\n  },\n  {\n    ready: false,\n    count: 5,\n    name: 'pink',\n    color: '#d850b0',\n    left: 'o',\n    right: 'p',\n  },\n  {\n    ready: false,\n    count: 6,\n    name: 'blue',\n    color: '#02a0c8',\n    left: 'mouse1',\n    right: 'mouse2',\n  },\n];\n\n/**\n * Dependencies required by PlayerManager\n */\nexport interface PlayerManagerDependencies {\n  /** Canvas rendering context for game canvas */\n  context: CanvasRenderingContext2D;\n\n  /** Player dependencies (input, fps, dimensions) */\n  playerDependencies: PlayerDependencies;\n\n  /** Optional player constants (collision tolerance, timing) */\n  playerConstants?: PlayerConstants;\n\n  /** Callback when new round should start */\n  onNewRound?: () => void;\n\n  /** Callback when game should finish */\n  onFinish?: () => void;\n\n  /** Callback when a player dies (to increment scores) */\n  onPlayerDeath?: (playerName: string) => void;\n}\n\n/**\n * PlayerManager class\n *\n * Manages the player pool, round state, and game loop.\n */\nexport class PlayerManager implements IPlayerManager {\n  // Public readonly properties\n  public get running(): boolean {\n    return this.#running;\n  }\n\n  public get roundCount(): number {\n    return this.#roundCount;\n  }\n\n  public get maxRounds(): number {\n    return this.#maxRounds;\n  }\n\n  public get playerTemplates(): readonly PlayerTemplate[] {\n    return this.#playerTemplates;\n  }\n\n  public get pool(): readonly IPlayer[] {\n    return this.#pool;\n  }\n\n  // Private state\n  #running: boolean = false;\n  #roundCount: number = 0;\n  #maxRounds: number = 0;\n\n  // Player templates (mutable for ready state)\n  #playerTemplates: PlayerTemplate[];\n\n  // Active player instances\n  #pool: IPlayer[] = [];\n\n  // Dependencies\n  #context: CanvasRenderingContext2D;\n  #playerDependencies: PlayerDependencies;\n  #playerConstants?: PlayerConstants;\n\n  // Callbacks\n  #onNewRound?: () => void;\n  #onFinish?: () => void;\n  #onPlayerDeath?: (playerName: string) => void;\n\n  /**\n   * Create a new player manager\n   *\n   * @param dependencies - Dependencies including context, player deps, and callbacks\n   * @param playerTemplates - Optional custom player templates (uses defaults if not provided)\n   */\n  constructor(\n    dependencies: PlayerManagerDependencies,\n    playerTemplates?: PlayerTemplate[]\n  ) {\n    this.#context = dependencies.context;\n    this.#playerDependencies = dependencies.playerDependencies;\n    this.#playerConstants = dependencies.playerConstants;\n    this.#onNewRound = dependencies.onNewRound;\n    this.#onFinish = dependencies.onFinish;\n    this.#onPlayerDeath = dependencies.onPlayerDeath;\n\n    // Use custom templates or defaults\n    this.#playerTemplates = playerTemplates\n      ? [...playerTemplates]\n      : [...DEFAULT_PLAYER_TEMPLATES];\n  }\n\n  /**\n   * Initialize the player manager for a new game\n   *\n   * Creates Player instances for all players marked as ready.\n   *\n   * @param config - Game configuration including maxRounds and physics\n   */\n  public init(config: PlayerManagerConfig): void {\n    this.#maxRounds = config.maxRounds;\n    this.#roundCount = 0;\n    this.#pool = [];\n\n    // Create death callback that will be passed to each player\n    const onPlayerDeath: OnPlayerDeath = (playerName: string) => {\n      // Notify game to increment scores for surviving players\n      if (this.#onPlayerDeath) {\n        this.#onPlayerDeath(playerName);\n      }\n\n      // Check if round should end\n      this.checkRoundOver();\n    };\n\n    // Create Player instances for ready players\n    for (const template of this.#playerTemplates) {\n      if (template.ready) {\n        const player = createPlayer(\n          template,\n          config.physics,\n          this.#playerDependencies,\n          this.#playerConstants,\n          onPlayerDeath\n        );\n\n        // Preserve score if player already exists (for subsequent rounds)\n        const existing = this.#pool.find((p) => p.name === template.name);\n        if (existing) {\n          player.score = existing.score;\n        }\n\n        this.#pool.push(player);\n      }\n    }\n  }\n\n  /**\n   * Start a new round\n   *\n   * Clears the canvas and initializes all players.\n   */\n  public startRound(): void {\n    this.#running = true;\n\n    // Clear game canvas\n    this.#context.clearRect(\n      0,\n      0,\n      this.#playerDependencies.dimensions.width,\n      this.#playerDependencies.dimensions.height\n    );\n\n    // Initialize all players for the new round\n    for (const player of this.#pool) {\n      player.init();\n    }\n  }\n\n  /**\n   * Main animation/game loop\n   *\n   * Updates and draws all living players if round is active.\n   * Handles space bar input for starting new round or finishing game.\n   */\n  public animate(): void {\n    if (this.#running) {\n      // Draw all living players\n      for (const player of this.#pool) {\n        if (!player.dead) {\n          player.draw();\n        }\n      }\n    } else {\n      // Check for space bar to start next round or finish game\n      if (this.#playerDependencies.inputManager.isKeyPressed('space')) {\n        if (this.#roundCount < this.#maxRounds) {\n          // Start next round\n          if (this.#onNewRound) {\n            this.#onNewRound();\n          }\n        } else {\n          // Game over\n          this.#running = false;\n          if (this.#onFinish) {\n            this.#onFinish();\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Check if the round should end\n   *\n   * Called when a player dies. Ends the round if only one player remains alive.\n   */\n  public checkRoundOver(): void {\n    let deadCount = 0;\n\n    // Count dead players\n    for (const player of this.#pool) {\n      if (player.dead) {\n        deadCount++;\n      }\n\n      // End round if all but one player are dead\n      if (deadCount >= this.#pool.length - 1) {\n        this.#running = false;\n        this.#roundCount++;\n        break;\n      }\n    }\n  }\n}\n\n/**\n * Create a new player manager instance\n *\n * Factory function for convenient instantiation.\n *\n * @param dependencies - Dependencies including context, player deps, and callbacks\n * @param playerTemplates - Optional custom player templates\n * @returns New PlayerManager instance\n */\nexport function createPlayerManager(\n  dependencies: PlayerManagerDependencies,\n  playerTemplates?: PlayerTemplate[]\n): IPlayerManager {\n  return new PlayerManager(dependencies, playerTemplates);\n}\n","/**\n * Game Controller\n *\n * Main game controller that orchestrates all game systems and manages game state.\n *\n * Migrated from Game function in Game.js with improvements:\n * - Class-based with proper encapsulation\n * - State machine for game flow\n * - Dependency injection for all components\n * - Type-safe configuration\n * - No global dependencies\n * - Canvas layer management\n */\n\nimport type {\n  GameState,\n  CanvasLayers,\n  GameDependencies,\n  IGame,\n  ImageRepository,\n  PlayerScore,\n} from '../types/game.types';\nimport type { IBackground } from '../types/game.types';\nimport type { ISplashScreen } from '../types/game.types';\nimport type { IEndScreen } from '../types/game.types';\nimport type { IScoreBoard } from '../types/score.types';\nimport type { IFpsCounter } from '../types/fps.types';\nimport type { IPlayerSelector } from '../types/player.types';\nimport type { IAdvancedSettings } from '../types/settings.types';\nimport type { IPlayerManager } from '../types/player.types';\nimport type { IInputManager } from '../types/input.types';\n\nimport { GameState as GameStateEnum } from '../types/game.types';\nimport { createBackground } from '../ui/components/Background';\nimport { createSplashScreen } from '../ui/screens/SplashScreen';\nimport { createEndScreen } from '../ui/screens/EndScreen';\nimport { createScoreBoard } from '../ui/components/ScoreBoard';\nimport { createFpsCounter } from '../core/FpsCounter';\nimport { createPlayerSelector } from '../ui/screens/PlayerSelector';\nimport { createAdvancedSettings } from '../ui/components/AdvancedSettings';\nimport { createPlayerManager } from '../game/managers/PlayerManager';\n\n/**\n * Game controller configuration\n */\nexport interface GameConfig {\n  /** Image repository with loaded sprites */\n  images: ImageRepository;\n\n  /** Input manager for keyboard/mouse */\n  inputManager: IInputManager;\n\n  /** Dependencies (container element, etc.) */\n  dependencies: GameDependencies;\n}\n\n/**\n * Game class\n *\n * Main game controller managing state, components, and game flow.\n */\nexport class Game implements IGame {\n  // Public readonly properties\n  public get state(): GameState {\n    return this.#state;\n  }\n\n  public get started(): boolean {\n    return this.#state === GameStateEnum.Playing;\n  }\n\n  public get width(): number {\n    return this.#width;\n  }\n\n  public get height(): number {\n    return this.#height;\n  }\n\n  // Private state\n  #state: GameState = GameStateEnum.Splash;\n  #width: number = 0;\n  #height: number = 0;\n\n  // Canvas layers\n  #layers!: CanvasLayers;\n\n  // Dependencies\n  #images: ImageRepository;\n  #inputManager: IInputManager;\n  #dependencies: GameDependencies;\n\n  // Components\n  #background!: IBackground;\n  #splash!: ISplashScreen;\n  #end!: IEndScreen;\n  #scoreBoard!: IScoreBoard;\n  #fpsCounter!: IFpsCounter;\n  #playerSelector!: IPlayerSelector;\n  #advancedSettings!: IAdvancedSettings;\n  #playerManager!: IPlayerManager;\n\n  /**\n   * Create a new game controller\n   *\n   * @param config - Game configuration\n   */\n  constructor(config: GameConfig) {\n    this.#images = config.images;\n    this.#inputManager = config.inputManager;\n    this.#dependencies = config.dependencies;\n  }\n\n  /**\n   * Initialize the game\n   *\n   * Sets up canvases, components, and shows splash screen.\n   */\n  public init(): void {\n    // Create canvas layers\n    this.#createLayers();\n\n    // Initialize components (must be before calculateSize since it needs scoreBoard)\n    this.#initializeComponents();\n\n    // Calculate initial size\n    this.#calculateSize();\n\n    // Show splash screen\n    this.showSplashScreen();\n  }\n\n  /**\n   * Handle window resize\n   *\n   * Recalculates canvas sizes and redraws current screen.\n   */\n  public onSizeChange(): void {\n    this.#calculateSize();\n\n    // Redraw appropriate screen based on state\n    if (this.#state === GameStateEnum.Playing) {\n      this.#background.draw(this.#width, this.#height, this.#scoreBoard.width);\n      this.#scoreBoard.draw(\n        this.#playerManager.pool.map((p) => ({\n          name: p.name,\n          color: p.color,\n          score: p.score,\n          dead: p.dead,\n        })),\n        this.#height\n      );\n    } else if (this.#state === GameStateEnum.Splash) {\n      this.showSplashScreen();\n    } else if (this.#state === GameStateEnum.Select) {\n      this.#playerSelector.show(\n        Array.from(this.#playerManager.playerTemplates),\n        this.#width,\n        this.#height\n      );\n    } else if (this.#state === GameStateEnum.End) {\n      const scores: PlayerScore[] = this.#playerManager.pool.map((p) => ({\n        name: p.name,\n        color: p.color,\n        score: p.score,\n      }));\n\n      this.#end.show(this.#images.end, scores, this.#width, this.#height);\n    }\n  }\n\n  /**\n   * Show splash screen\n   *\n   * Transitions to splash state.\n   */\n  public showSplashScreen(): void {\n    this.#state = GameStateEnum.Splash;\n\n    // Show cursor\n    if (this.#dependencies.onShowCursor) {\n      this.#dependencies.onShowCursor();\n    }\n\n    // Clear player selector\n    this.#playerSelector.clear(\n      Array.from(this.#playerManager.playerTemplates),\n      this.#width,\n      this.#height\n    );\n\n    // Show splash\n    this.#splash.show(this.#images.splash, this.#width, this.#height);\n  }\n\n  /**\n   * Show player selection screen\n   *\n   * Transitions to select state.\n   */\n  public showSelectScreen(): void {\n    this.#state = GameStateEnum.Select;\n\n    // Clear splash\n    this.#splash.clear(this.#width, this.#height);\n\n    // Show advanced settings and player selector\n    this.#advancedSettings.show();\n    this.#playerSelector.show(\n      Array.from(this.#playerManager.playerTemplates),\n      this.#width,\n      this.#height\n    );\n\n    // Show GitHub link if provided\n    if (this.#dependencies.githubElement) {\n      this.#dependencies.githubElement.style.display = 'block';\n    }\n  }\n\n  /**\n   * Start the game\n   *\n   * Begins a new game with selected players.\n   * Transitions to playing state.\n   */\n  public start(): void {\n    this.#state = GameStateEnum.Playing;\n\n    // Hide cursor\n    if (this.#dependencies.onHideCursor) {\n      this.#dependencies.onHideCursor();\n    }\n\n    // Get configuration from advanced settings\n    const config = this.#advancedSettings.getConfiguration();\n\n    // Initialize player manager\n    this.#playerManager.init({\n      maxRounds: config.maxRounds,\n      physics: {\n        size: config.size,\n        speed: config.speed,\n        curveSpeed: config.curveSpeed,\n        holeRate: config.holeRate,\n        holeRateRnd: config.holeRateRnd,\n        holeSize: config.holeSize,\n        holeSizeRnd: config.holeSizeRnd,\n      },\n    });\n\n    // Hide advanced settings\n    this.#advancedSettings.hide();\n\n    // Clear player selector\n    this.#playerSelector.clear(\n      Array.from(this.#playerManager.playerTemplates),\n      this.#width,\n      this.#height\n    );\n\n    // Draw scoreboard\n    this.#scoreBoard.draw(\n      this.#playerManager.pool.map((p) => ({\n        name: p.name,\n        color: p.color,\n        score: p.score,\n        dead: p.dead,\n      })),\n      this.#height\n    );\n\n    // Start first round\n    this.newRound();\n\n    // Hide GitHub link if provided\n    if (this.#dependencies.githubElement) {\n      this.#dependencies.githubElement.style.display = 'none';\n    }\n  }\n\n  /**\n   * Start a new round\n   *\n   * Called at the beginning of each round.\n   */\n  public newRound(): void {\n    this.#playerManager.startRound();\n    this.#background.draw(this.#width, this.#height, this.#scoreBoard.width);\n  }\n\n  /**\n   * End the game\n   *\n   * Shows end screen with final scores.\n   * Transitions to end state.\n   */\n  public finish(): void {\n    this.#state = GameStateEnum.End;\n\n    // Show cursor\n    if (this.#dependencies.onShowCursor) {\n      this.#dependencies.onShowCursor();\n    }\n\n    // Clear background and scoreboard\n    this.#background.clear(this.#width, this.#height);\n    this.#scoreBoard.clear();\n\n    // Show end screen\n    const scores: PlayerScore[] = this.#playerManager.pool.map((p) => ({\n      name: p.name,\n      color: p.color,\n      score: p.score,\n    }));\n\n    this.#end.show(this.#images.end, scores, this.#width, this.#height);\n  }\n\n  /**\n   * Main animation loop tick\n   *\n   * Should be called once per frame.\n   * Delegates to appropriate screen/state handler.\n   */\n  public animate(): void {\n    // Update FPS counter\n    this.#fpsCounter.update();\n\n    // Handle state-specific logic\n    if (this.#state === GameStateEnum.Playing) {\n      this.#playerManager.animate();\n\n      // Update scoreboard when player dies\n      this.#scoreBoard.draw(\n        this.#playerManager.pool.map((p) => ({\n          name: p.name,\n          color: p.color,\n          score: p.score,\n          dead: p.dead,\n        })),\n        this.#height\n      );\n    } else if (this.#state === GameStateEnum.Splash) {\n      this.#splash.listen(() => {\n        this.showSelectScreen();\n      });\n    } else if (this.#state === GameStateEnum.Select) {\n      this.#playerSelector.listen(\n        Array.from(this.#playerManager.playerTemplates),\n        this.#images,\n        this.#width,\n        this.#height,\n        () => {\n          this.start();\n        }\n      );\n    } else if (this.#state === GameStateEnum.End) {\n      this.#end.listen(() => {\n        this.showSelectScreen();\n      });\n    }\n  }\n\n  /**\n   * Create canvas layers\n   *\n   * Creates or retrieves canvas elements for each layer.\n   */\n  #createLayers(): void {\n    const layerNames = ['main', 'texts', 'screens', 'score'] as const;\n\n    this.#layers = {} as CanvasLayers;\n\n    for (const name of layerNames) {\n      // Try to get existing canvas\n      let element = document.getElementById(name) as HTMLCanvasElement | null;\n\n      // Create if doesn't exist\n      if (!element) {\n        element = document.createElement('canvas');\n        element.id = name;\n        this.#dependencies.container.appendChild(element);\n      }\n\n      // Get 2D context\n      const context = element.getContext('2d');\n      if (!context) {\n        throw new Error(`Failed to get 2D context for canvas: ${name}`);\n      }\n\n      // Store layer\n      this.#layers[name] = { element, context };\n    }\n  }\n\n  /**\n   * Calculate canvas sizes\n   *\n   * Sets canvas dimensions based on window size.\n   */\n  #calculateSize(): void {\n    this.#width = window.innerWidth;\n    this.#height = window.innerHeight;\n\n    // Set all canvas sizes\n    for (const layer of Object.values(this.#layers)) {\n      layer.element.width = this.#width;\n      layer.element.height = this.#height;\n    }\n\n    // Position score canvas\n    this.#layers.score.element.style.left = `${\n      this.#width - this.#scoreBoard.width\n    }px`;\n    this.#layers.score.element.width = this.#scoreBoard.width;\n  }\n\n  /**\n   * Initialize all game components\n   *\n   * Creates instances of all game systems with proper dependencies.\n   */\n  #initializeComponents(): void {\n    // Create FPS counter (needed by player manager)\n    this.#fpsCounter = createFpsCounter(this.#layers.texts.context);\n\n    // Create scoreboard first (needed by player manager callback)\n    this.#scoreBoard = createScoreBoard(this.#layers.score.context);\n\n    // Create dimensions object for player manager\n    const dimensions = {\n      get width() {\n        return window.innerWidth;\n      },\n      get height() {\n        return window.innerHeight;\n      },\n      get scoreWidth() {\n        return 150; // ScoreBoard default width\n      },\n    };\n\n    // Create player dependencies\n    const playerDependencies = {\n      context: this.#layers.main.context,\n      inputManager: this.#inputManager,\n      fpsProvider: this.#fpsCounter,\n      dimensions,\n    };\n\n    // Create player manager with callbacks\n    this.#playerManager = createPlayerManager({\n      context: this.#layers.main.context,\n      playerDependencies,\n      onNewRound: () => {\n        this.newRound();\n      },\n      onFinish: () => {\n        this.finish();\n      },\n      onPlayerDeath: (playerName: string) => {\n        // Only increment scores if round is still active\n        if (this.#playerManager.running) {\n          this.#scoreBoard.incrementScores(\n            playerName,\n            this.#playerManager.pool\n          );\n        }\n      },\n    });\n\n    // Create background\n    this.#background = createBackground(this.#layers.main.context);\n\n    // Create splash screen\n    this.#splash = createSplashScreen(\n      this.#layers.screens.context,\n      this.#inputManager\n    );\n\n    // Create end screen\n    this.#end = createEndScreen(\n      this.#layers.screens.context,\n      this.#inputManager\n    );\n\n    // Create player selector\n    this.#playerSelector = createPlayerSelector(\n      this.#layers.screens.context,\n      this.#inputManager\n    );\n\n    // Create advanced settings (needs DOM elements)\n    this.#advancedSettings = createAdvancedSettings();\n\n    // Initialize advanced settings with DOM elements\n    // Note: This requires DOM elements to exist\n    const advancedPanel = document.getElementById('advanced');\n    const advancedButton = document.getElementById(\n      'advanced-button'\n    ) as HTMLButtonElement;\n    const advancedForm = document.getElementById('advanced-form');\n    const classicButton = document.querySelector(\n      '[data-preset=\"classic\"]'\n    ) as HTMLButtonElement;\n    const presetButtons = Array.from(\n      document.querySelectorAll('[data-preset]')\n    ) as HTMLButtonElement[];\n\n    if (\n      advancedPanel &&\n      advancedButton &&\n      advancedForm &&\n      classicButton &&\n      presetButtons.length > 0\n    ) {\n      this.#advancedSettings.initialize({\n        advancedPanel: advancedPanel as HTMLElement,\n        advancedButton,\n        form: advancedForm as HTMLElement,\n        classicButton,\n        presetButtons,\n        inputs: {\n          maxRounds: document.getElementById('maxRounds') as HTMLInputElement,\n          size: document.getElementById('size') as HTMLInputElement,\n          speed: document.getElementById('speed') as HTMLInputElement,\n          curveSpeed: document.getElementById('curveSpeed') as HTMLInputElement,\n          holeRate: document.getElementById('holeRate') as HTMLInputElement,\n          holeRateRnd: document.getElementById(\n            'holeRateRnd'\n          ) as HTMLInputElement,\n          holeSize: document.getElementById('holeSize') as HTMLInputElement,\n          holeSizeRnd: document.getElementById(\n            'holeSizeRnd'\n          ) as HTMLInputElement,\n        },\n      });\n    }\n  }\n}\n\n/**\n * Create a new game controller\n *\n * Factory function for convenient instantiation.\n *\n * @param config - Game configuration\n * @returns New Game instance\n */\nexport function createGame(config: GameConfig): IGame {\n  return new Game(config);\n}\n","/**\n * Main Entry Point\n *\n * Initializes and starts the Zatacka game.\n *\n * This is the main entry point that:\n * - Loads all game images\n * - Initializes input handling\n * - Creates the game controller\n * - Starts the animation loop\n * - Handles window resize events\n */\n\nimport { createImageLoader } from './core/ImageLoader';\nimport { KeyboardManager } from './core/KeyboardManager';\nimport { createGame } from './core/Game';\nimport type { IGame } from './types/game.types';\nimport type { ImageRepository } from './types/game.types';\n\n/**\n * Game instance (created after images load)\n */\nlet game: IGame | null = null;\n\n/**\n * Request animation frame polyfill\n *\n * Provides cross-browser compatibility for requestAnimationFrame.\n * Falls back to setTimeout if native implementation is unavailable.\n */\nconst requestAnimFrame = ((): ((callback: FrameRequestCallback) => number) => {\n  return (\n    window.requestAnimationFrame ||\n    (window as any).webkitRequestAnimationFrame ||\n    (window as any).mozRequestAnimationFrame ||\n    (window as any).oRequestAnimationFrame ||\n    (window as any).msRequestAnimationFrame ||\n    function (callback: FrameRequestCallback): number {\n      return window.setTimeout(callback, 1000 / 60);\n    }\n  );\n})();\n\n/**\n * Main animation loop\n *\n * Called once per frame via requestAnimationFrame.\n * Delegates to game controller if initialized.\n */\nfunction animate(): void {\n  requestAnimFrame(animate);\n\n  if (game) {\n    game.animate();\n  }\n}\n\n/**\n * Handle window resize events\n *\n * Notifies game controller to recalculate canvas sizes.\n */\nfunction handleResize(): void {\n  if (game) {\n    game.onSizeChange();\n  }\n}\n\n/**\n * Show/hide cursor helpers\n */\nfunction showCursor(): void {\n  document.body.style.cursor = 'initial';\n}\n\nfunction hideCursor(): void {\n  document.body.style.cursor = 'none';\n}\n\n/**\n * Initialize the game\n *\n * Called after all images have loaded.\n * Sets up input, creates game controller, and starts animation loop.\n *\n * @param images - Loaded image repository\n */\nfunction initializeGame(images: ImageRepository): void {\n  // Get game container\n  const container = document.getElementById('game');\n  if (!container) {\n    console.error('Game container not found');\n    return;\n  }\n\n  // Get optional GitHub link element\n  const githubElement = document.getElementById('github') || undefined;\n\n  // Initialize input manager\n  const inputManager = KeyboardManager.getInstance();\n  inputManager.initialize(container);\n\n  // Create game controller\n  game = createGame({\n    images,\n    inputManager,\n    dependencies: {\n      container,\n      githubElement,\n      onShowCursor: showCursor,\n      onHideCursor: hideCursor,\n    },\n  });\n\n  // Initialize game systems\n  game.init();\n\n  // Start animation loop\n  animate();\n\n  // Set up window resize handler\n  window.addEventListener('resize', handleResize);\n}\n\n/**\n * Load game images\n *\n * Creates image loader and starts loading all game sprites.\n */\nfunction loadImages(): void {\n  const imageLoader = createImageLoader({\n    images: {\n      splash: 'achtung-small.png',\n      end: 'achtung-konec-hry.png',\n      red: 'red.png',\n      yellow: 'yellow.png',\n      orange: 'orange.png',\n      green: 'green.png',\n      pink: 'pink.png',\n      blue: 'blue.png',\n    },\n    onComplete: () => {\n      // All images loaded, initialize game\n      initializeGame(imageLoader.images as ImageRepository);\n    },\n  });\n}\n\n/**\n * Start the application\n *\n * Entry point when DOM is ready.\n */\nfunction start(): void {\n  loadImages();\n}\n\n// Start when DOM is ready\nif (document.readyState === 'loading') {\n  document.addEventListener('DOMContentLoaded', start);\n} else {\n  // DOM already loaded\n  start();\n}\n"],"names":["ImageLoader","#images","#loadedCount","#totalCount","#onComplete","config","key","src","#loadImage","image","#handleImageLoaded","createImageLoader","KeyboardManager","status","keyName","gameElement","e","pressed","keyboardManager","_","prop","GameState","DEFAULT_CONFIG","Background","#context","#config","context","gameWidth","gameHeight","scoreWidth","createBackground","SplashScreen","#active","#inputManager","#counter","inputManager","x","y","onDismiss","createSplashScreen","EndScreen","scores","imgX","imgY","#drawScores","totalPlayers","i","player","createEndScreen","MAX_CLEAR_HEIGHT","ScoreBoard","players","#drawBackground","#drawPlayerScores","deadPlayerName","position","#calculatePlayerPosition","index","createScoreBoard","FpsCounter","#currentFps","#lastUpdateTime","#frameCount","currentTime","#calculateFps","shouldDraw","#drawFpsText","deltaMs","fps","createFpsCounter","PlayerSelector","playerTemplates","#showPlayerControls","#showInstructions","imageRepo","onStart","#handlePlayerInput","#handleStartInput","#isImageValid","iconX","iconY","createPlayerSelector","configurations","validateConfiguration","AdvancedSettings","#elements","#boundHandlers","elements","#setupEventHandlers","inputs","maxRounds","size","speed","curveSpeed","holeRate","holeRateRnd","holeSize","holeSizeRnd","preset","#populateFields","#cleanupEventHandlers","toggleHandler","#handleAdvancedButtonClick","button","handler","#handlePresetButtonClick","createAdvancedSettings","DEFAULT_CONSTANTS","Player","#left","#right","#size","#speed","#curveSpeed","#holeRate","#holeRateRnd","#holeSize","#holeSizeRnd","#fpsProvider","#dimensions","#afterDieTime","#collisionTolerance","#startTime","#x","#y","#angle","#dying","#afterDieCount","#hole","#holeCounter","#nextHole","#nextHoleSize","#onDeath","template","physics","dependencies","constants","onDeath","finalConstants","#getNextHole","#getNextHoleSize","speedMultiplier","adjustedSpeed","adjustedAngSpeed","angleRad","#createHole","#isColliding","#drawStroke","rcol","rad1","y1","x1","p1","rad2","y2","x2","p2","createPlayer","DEFAULT_PLAYER_TEMPLATES","PlayerManager","#running","#roundCount","#maxRounds","#playerTemplates","#pool","#playerDependencies","#playerConstants","#onNewRound","#onFinish","#onPlayerDeath","onPlayerDeath","playerName","existing","p","deadCount","createPlayerManager","Game","#state","GameStateEnum","#width","#height","#layers","#dependencies","#background","#splash","#end","#scoreBoard","#fpsCounter","#playerSelector","#advancedSettings","#playerManager","#createLayers","#initializeComponents","#calculateSize","layerNames","name","element","layer","dimensions","playerDependencies","advancedPanel","advancedButton","advancedForm","classicButton","presetButtons","createGame","game","requestAnimFrame","callback","animate","handleResize","showCursor","hideCursor","initializeGame","images","container","githubElement","loadImages","imageLoader","start"],"mappings":"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"}